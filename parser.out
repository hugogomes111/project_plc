Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CASE
    COMMENT
    FILE
    FORWARD
    GOTO
    IN
    LABEL
    LENGTH
    NIL
    PACKED
    READ
    RECORD
    SET
    TYPE
    WITH

Grammar

Rule 0     S' -> Program
Rule 1     Program -> PROGRAM ID ; Code .
Rule 2     Code -> Declarations BEGIN Blocks END
Rule 3     Declarations -> Vars Declarations
Rule 4     Declarations -> Consts Declarations
Rule 5     Declarations -> Functions Declarations
Rule 6     Declarations -> Procedures Declarations
Rule 7     Declarations -> <empty>
Rule 8     Consts -> CONST ConstDefs
Rule 9     ConstDefs -> ID = ConstValue ; ConstDefs
Rule 10    ConstDefs -> <empty>
Rule 11    ConstValue -> INT
Rule 12    ConstValue -> REAL
Rule 13    ConstValue -> STR
Rule 14    ConstValue -> TRUE
Rule 15    ConstValue -> FALSE
Rule 16    Vars -> VAR VarList
Rule 17    VarList -> IDList : Type ; VarList
Rule 18    VarList -> <empty>
Rule 19    IDList -> ID RestoIDs
Rule 20    RestoIDs -> , ID RestoIDs
Rule 21    RestoIDs -> <empty>
Rule 22    Type -> INTEGER
Rule 23    Type -> BOOLEAN
Rule 24    Type -> STRING
Rule 25    Type -> REALTYPE
Rule 26    Type -> CHAR
Rule 27    Type -> ARRAY [ INT DOTDOT INT ] OF Type
Rule 28    Functions -> FUNCTION ID ( Parameters ) : Type ; FunctionBody
Rule 29    Functions -> FUNCTION ID : Type ; FunctionBody
Rule 30    FunctionBody -> Declarations BEGIN Blocks END ;
Rule 31    Procedures -> PROCEDURE ID ( Parameters ) ; ProcedureBody
Rule 32    Procedures -> PROCEDURE ID ; ProcedureBody
Rule 33    ProcedureBody -> Declarations BEGIN Blocks END ;
Rule 34    Parameters -> IDList : Type MoreParameters
Rule 35    Parameters -> <empty>
Rule 36    MoreParameters -> ; IDList : Type MoreParameters
Rule 37    MoreParameters -> <empty>
Rule 38    Blocks -> Block Blocks
Rule 39    Blocks -> <empty>
Rule 40    Block -> WRITELN ( WriteList ) ;
Rule 41    Block -> WRITE ( WriteList ) ;
Rule 42    WriteList -> WriteItem MoreWriteItems
Rule 43    MoreWriteItems -> , WriteItem MoreWriteItems
Rule 44    MoreWriteItems -> <empty>
Rule 45    WriteItem -> STR
Rule 46    WriteItem -> Exp
Rule 47    Block -> READLN ( ID ) ;
Rule 48    Block -> READLN ( ID [ Exp ] ) ;
Rule 49    Block -> ID ASSIGN Exp ;
Rule 50    Block -> ID [ Exp ] ASSIGN Exp ;
Rule 51    Block -> IF Condition THEN Block
Rule 52    Block -> IF Condition THEN Block ELSE Block
Rule 53    Block -> IF Condition THEN BEGIN Blocks END ;
Rule 54    Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
Rule 55    Block -> WHILE Condition DO Block
Rule 56    Block -> WHILE Condition DO BEGIN Blocks END ;
Rule 57    Block -> FOR ID ASSIGN Exp TO Exp DO Block
Rule 58    Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
Rule 59    Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block
Rule 60    Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
Rule 61    Block -> REPEAT Blocks UNTIL Condition ;
Rule 62    Condition -> Condition OR CondTerm
Rule 63    Condition -> CondTerm
Rule 64    CondTerm -> CondTerm AND CondFactor
Rule 65    CondTerm -> CondFactor
Rule 66    CondFactor -> NOT CondFactor
Rule 67    CondFactor -> Exp RelOp Exp
Rule 68    CondFactor -> ( Condition )
Rule 69    CondFactor -> TRUE
Rule 70    CondFactor -> FALSE
Rule 71    RelOp -> =
Rule 72    RelOp -> NE
Rule 73    RelOp -> <
Rule 74    RelOp -> LE
Rule 75    RelOp -> >
Rule 76    RelOp -> GE
Rule 77    Exp -> Exp + Term
Rule 78    Exp -> Exp - Term
Rule 79    Exp -> Term
Rule 80    Term -> Term * Factor
Rule 81    Term -> Term / Factor
Rule 82    Term -> Term DIV Factor
Rule 83    Term -> Term MOD Factor
Rule 84    Term -> Factor
Rule 85    Factor -> INT
Rule 86    Factor -> REAL
Rule 87    Factor -> STR
Rule 88    Factor -> TRUE
Rule 89    Factor -> FALSE
Rule 90    Factor -> ID
Rule 91    Factor -> ID [ Exp ]
Rule 92    Factor -> ID ( ArgumentList )
Rule 93    Factor -> ( Exp )
Rule 94    ArgumentList -> Exp MoreArguments
Rule 95    ArgumentList -> <empty>
Rule 96    MoreArguments -> , Exp MoreArguments
Rule 97    MoreArguments -> <empty>

Terminals, with rules where they appear

(                    : 28 31 40 41 47 48 68 92 93
)                    : 28 31 40 41 47 48 68 92 93
*                    : 80
+                    : 77
,                    : 20 43 96
-                    : 78
.                    : 1
/                    : 81
:                    : 17 28 29 34 36
;                    : 1 9 17 28 29 30 31 32 33 36 40 41 47 48 49 50 53 54 56 58 60 61
<                    : 73
=                    : 9 71
>                    : 75
AND                  : 64
ARRAY                : 27
ASSIGN               : 49 50 57 58 59 60
BEGIN                : 2 30 33 53 54 54 56 58 60
BOOLEAN              : 23
CASE                 : 
CHAR                 : 26
COMMENT              : 
CONST                : 8
DIV                  : 82
DO                   : 55 56 57 58 59 60
DOTDOT               : 27
DOWNTO               : 59 60
ELSE                 : 52 54
END                  : 2 30 33 53 54 54 56 58 60
FALSE                : 15 70 89
FILE                 : 
FOR                  : 57 58 59 60
FORWARD              : 
FUNCTION             : 28 29
GE                   : 76
GOTO                 : 
ID                   : 1 9 19 20 28 29 31 32 47 48 49 50 57 58 59 60 90 91 92
IF                   : 51 52 53 54
IN                   : 
INT                  : 11 27 27 85
INTEGER              : 22
LABEL                : 
LE                   : 74
LENGTH               : 
MOD                  : 83
NE                   : 72
NIL                  : 
NOT                  : 66
OF                   : 27
OR                   : 62
PACKED               : 
PROCEDURE            : 31 32
PROGRAM              : 1
READ                 : 
READLN               : 47 48
REAL                 : 12 86
REALTYPE             : 25
RECORD               : 
REPEAT               : 61
SET                  : 
STR                  : 13 45 87
STRING               : 24
THEN                 : 51 52 53 54
TO                   : 57 58
TRUE                 : 14 69 88
TYPE                 : 
UNTIL                : 61
VAR                  : 16
WHILE                : 55 56
WITH                 : 
WRITE                : 41
WRITELN              : 40
[                    : 27 48 50 91
]                    : 27 48 50 91
error                : 

Nonterminals, with rules where they appear

ArgumentList         : 92
Block                : 38 51 52 52 55 57 59
Blocks               : 2 30 33 38 53 54 54 56 58 60 61
Code                 : 1
CondFactor           : 64 65 66
CondTerm             : 62 63 64
Condition            : 51 52 53 54 55 56 61 62 68
ConstDefs            : 8 9
ConstValue           : 9
Consts               : 4
Declarations         : 2 3 4 5 6 30 33
Exp                  : 46 48 49 50 50 57 57 58 58 59 59 60 60 67 67 77 78 91 93 94 96
Factor               : 80 81 82 83 84
FunctionBody         : 28 29
Functions            : 5
IDList               : 17 34 36
MoreArguments        : 94 96
MoreParameters       : 34 36
MoreWriteItems       : 42 43
Parameters           : 28 31
ProcedureBody        : 31 32
Procedures           : 6
Program              : 0
RelOp                : 67
RestoIDs             : 19 20
Term                 : 77 78 79 80 81 82 83
Type                 : 17 27 28 29 34 36
VarList              : 16 17
Vars                 : 3
WriteItem            : 42 43
WriteList            : 40 41

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . PROGRAM ID ; Code .

    PROGRAM         shift and go to state 2

    Program                        shift and go to state 1

state 1

    (0) S' -> Program .



state 2

    (1) Program -> PROGRAM . ID ; Code .

    ID              shift and go to state 3


state 3

    (1) Program -> PROGRAM ID . ; Code .

    ;               shift and go to state 4


state 4

    (1) Program -> PROGRAM ID ; . Code .
    (2) Code -> . Declarations BEGIN Blocks END
    (3) Declarations -> . Vars Declarations
    (4) Declarations -> . Consts Declarations
    (5) Declarations -> . Functions Declarations
    (6) Declarations -> . Procedures Declarations
    (7) Declarations -> .
    (16) Vars -> . VAR VarList
    (8) Consts -> . CONST ConstDefs
    (28) Functions -> . FUNCTION ID ( Parameters ) : Type ; FunctionBody
    (29) Functions -> . FUNCTION ID : Type ; FunctionBody
    (31) Procedures -> . PROCEDURE ID ( Parameters ) ; ProcedureBody
    (32) Procedures -> . PROCEDURE ID ; ProcedureBody

    BEGIN           reduce using rule 7 (Declarations -> .)
    VAR             shift and go to state 11
    CONST           shift and go to state 12
    FUNCTION        shift and go to state 13
    PROCEDURE       shift and go to state 14

    Code                           shift and go to state 5
    Declarations                   shift and go to state 6
    Vars                           shift and go to state 7
    Consts                         shift and go to state 8
    Functions                      shift and go to state 9
    Procedures                     shift and go to state 10

state 5

    (1) Program -> PROGRAM ID ; Code . .

    .               shift and go to state 15


state 6

    (2) Code -> Declarations . BEGIN Blocks END

    BEGIN           shift and go to state 16


state 7

    (3) Declarations -> Vars . Declarations
    (3) Declarations -> . Vars Declarations
    (4) Declarations -> . Consts Declarations
    (5) Declarations -> . Functions Declarations
    (6) Declarations -> . Procedures Declarations
    (7) Declarations -> .
    (16) Vars -> . VAR VarList
    (8) Consts -> . CONST ConstDefs
    (28) Functions -> . FUNCTION ID ( Parameters ) : Type ; FunctionBody
    (29) Functions -> . FUNCTION ID : Type ; FunctionBody
    (31) Procedures -> . PROCEDURE ID ( Parameters ) ; ProcedureBody
    (32) Procedures -> . PROCEDURE ID ; ProcedureBody

    BEGIN           reduce using rule 7 (Declarations -> .)
    VAR             shift and go to state 11
    CONST           shift and go to state 12
    FUNCTION        shift and go to state 13
    PROCEDURE       shift and go to state 14

    Vars                           shift and go to state 7
    Declarations                   shift and go to state 17
    Consts                         shift and go to state 8
    Functions                      shift and go to state 9
    Procedures                     shift and go to state 10

state 8

    (4) Declarations -> Consts . Declarations
    (3) Declarations -> . Vars Declarations
    (4) Declarations -> . Consts Declarations
    (5) Declarations -> . Functions Declarations
    (6) Declarations -> . Procedures Declarations
    (7) Declarations -> .
    (16) Vars -> . VAR VarList
    (8) Consts -> . CONST ConstDefs
    (28) Functions -> . FUNCTION ID ( Parameters ) : Type ; FunctionBody
    (29) Functions -> . FUNCTION ID : Type ; FunctionBody
    (31) Procedures -> . PROCEDURE ID ( Parameters ) ; ProcedureBody
    (32) Procedures -> . PROCEDURE ID ; ProcedureBody

    BEGIN           reduce using rule 7 (Declarations -> .)
    VAR             shift and go to state 11
    CONST           shift and go to state 12
    FUNCTION        shift and go to state 13
    PROCEDURE       shift and go to state 14

    Consts                         shift and go to state 8
    Declarations                   shift and go to state 18
    Vars                           shift and go to state 7
    Functions                      shift and go to state 9
    Procedures                     shift and go to state 10

state 9

    (5) Declarations -> Functions . Declarations
    (3) Declarations -> . Vars Declarations
    (4) Declarations -> . Consts Declarations
    (5) Declarations -> . Functions Declarations
    (6) Declarations -> . Procedures Declarations
    (7) Declarations -> .
    (16) Vars -> . VAR VarList
    (8) Consts -> . CONST ConstDefs
    (28) Functions -> . FUNCTION ID ( Parameters ) : Type ; FunctionBody
    (29) Functions -> . FUNCTION ID : Type ; FunctionBody
    (31) Procedures -> . PROCEDURE ID ( Parameters ) ; ProcedureBody
    (32) Procedures -> . PROCEDURE ID ; ProcedureBody

    BEGIN           reduce using rule 7 (Declarations -> .)
    VAR             shift and go to state 11
    CONST           shift and go to state 12
    FUNCTION        shift and go to state 13
    PROCEDURE       shift and go to state 14

    Functions                      shift and go to state 9
    Declarations                   shift and go to state 19
    Vars                           shift and go to state 7
    Consts                         shift and go to state 8
    Procedures                     shift and go to state 10

state 10

    (6) Declarations -> Procedures . Declarations
    (3) Declarations -> . Vars Declarations
    (4) Declarations -> . Consts Declarations
    (5) Declarations -> . Functions Declarations
    (6) Declarations -> . Procedures Declarations
    (7) Declarations -> .
    (16) Vars -> . VAR VarList
    (8) Consts -> . CONST ConstDefs
    (28) Functions -> . FUNCTION ID ( Parameters ) : Type ; FunctionBody
    (29) Functions -> . FUNCTION ID : Type ; FunctionBody
    (31) Procedures -> . PROCEDURE ID ( Parameters ) ; ProcedureBody
    (32) Procedures -> . PROCEDURE ID ; ProcedureBody

    BEGIN           reduce using rule 7 (Declarations -> .)
    VAR             shift and go to state 11
    CONST           shift and go to state 12
    FUNCTION        shift and go to state 13
    PROCEDURE       shift and go to state 14

    Procedures                     shift and go to state 10
    Declarations                   shift and go to state 20
    Vars                           shift and go to state 7
    Consts                         shift and go to state 8
    Functions                      shift and go to state 9

state 11

    (16) Vars -> VAR . VarList
    (17) VarList -> . IDList : Type ; VarList
    (18) VarList -> .
    (19) IDList -> . ID RestoIDs

    VAR             reduce using rule 18 (VarList -> .)
    CONST           reduce using rule 18 (VarList -> .)
    FUNCTION        reduce using rule 18 (VarList -> .)
    PROCEDURE       reduce using rule 18 (VarList -> .)
    BEGIN           reduce using rule 18 (VarList -> .)
    ID              shift and go to state 23

    VarList                        shift and go to state 21
    IDList                         shift and go to state 22

state 12

    (8) Consts -> CONST . ConstDefs
    (9) ConstDefs -> . ID = ConstValue ; ConstDefs
    (10) ConstDefs -> .

    ID              shift and go to state 25
    VAR             reduce using rule 10 (ConstDefs -> .)
    CONST           reduce using rule 10 (ConstDefs -> .)
    FUNCTION        reduce using rule 10 (ConstDefs -> .)
    PROCEDURE       reduce using rule 10 (ConstDefs -> .)
    BEGIN           reduce using rule 10 (ConstDefs -> .)

    ConstDefs                      shift and go to state 24

state 13

    (28) Functions -> FUNCTION . ID ( Parameters ) : Type ; FunctionBody
    (29) Functions -> FUNCTION . ID : Type ; FunctionBody

    ID              shift and go to state 26


state 14

    (31) Procedures -> PROCEDURE . ID ( Parameters ) ; ProcedureBody
    (32) Procedures -> PROCEDURE . ID ; ProcedureBody

    ID              shift and go to state 27


state 15

    (1) Program -> PROGRAM ID ; Code . .

    $end            reduce using rule 1 (Program -> PROGRAM ID ; Code . .)


state 16

    (2) Code -> Declarations BEGIN . Blocks END
    (38) Blocks -> . Block Blocks
    (39) Blocks -> .
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    END             reduce using rule 39 (Blocks -> .)
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Blocks                         shift and go to state 28
    Block                          shift and go to state 29

state 17

    (3) Declarations -> Vars Declarations .

    BEGIN           reduce using rule 3 (Declarations -> Vars Declarations .)


state 18

    (4) Declarations -> Consts Declarations .

    BEGIN           reduce using rule 4 (Declarations -> Consts Declarations .)


state 19

    (5) Declarations -> Functions Declarations .

    BEGIN           reduce using rule 5 (Declarations -> Functions Declarations .)


state 20

    (6) Declarations -> Procedures Declarations .

    BEGIN           reduce using rule 6 (Declarations -> Procedures Declarations .)


state 21

    (16) Vars -> VAR VarList .

    VAR             reduce using rule 16 (Vars -> VAR VarList .)
    CONST           reduce using rule 16 (Vars -> VAR VarList .)
    FUNCTION        reduce using rule 16 (Vars -> VAR VarList .)
    PROCEDURE       reduce using rule 16 (Vars -> VAR VarList .)
    BEGIN           reduce using rule 16 (Vars -> VAR VarList .)


state 22

    (17) VarList -> IDList . : Type ; VarList

    :               shift and go to state 38


state 23

    (19) IDList -> ID . RestoIDs
    (20) RestoIDs -> . , ID RestoIDs
    (21) RestoIDs -> .

    ,               shift and go to state 40
    :               reduce using rule 21 (RestoIDs -> .)

    RestoIDs                       shift and go to state 39

state 24

    (8) Consts -> CONST ConstDefs .

    VAR             reduce using rule 8 (Consts -> CONST ConstDefs .)
    CONST           reduce using rule 8 (Consts -> CONST ConstDefs .)
    FUNCTION        reduce using rule 8 (Consts -> CONST ConstDefs .)
    PROCEDURE       reduce using rule 8 (Consts -> CONST ConstDefs .)
    BEGIN           reduce using rule 8 (Consts -> CONST ConstDefs .)


state 25

    (9) ConstDefs -> ID . = ConstValue ; ConstDefs

    =               shift and go to state 41


state 26

    (28) Functions -> FUNCTION ID . ( Parameters ) : Type ; FunctionBody
    (29) Functions -> FUNCTION ID . : Type ; FunctionBody

    (               shift and go to state 42
    :               shift and go to state 43


state 27

    (31) Procedures -> PROCEDURE ID . ( Parameters ) ; ProcedureBody
    (32) Procedures -> PROCEDURE ID . ; ProcedureBody

    (               shift and go to state 44
    ;               shift and go to state 45


state 28

    (2) Code -> Declarations BEGIN Blocks . END

    END             shift and go to state 46


state 29

    (38) Blocks -> Block . Blocks
    (38) Blocks -> . Block Blocks
    (39) Blocks -> .
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    END             reduce using rule 39 (Blocks -> .)
    UNTIL           reduce using rule 39 (Blocks -> .)
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Block                          shift and go to state 29
    Blocks                         shift and go to state 47

state 30

    (40) Block -> WRITELN . ( WriteList ) ;

    (               shift and go to state 48


state 31

    (41) Block -> WRITE . ( WriteList ) ;

    (               shift and go to state 49


state 32

    (47) Block -> READLN . ( ID ) ;
    (48) Block -> READLN . ( ID [ Exp ] ) ;

    (               shift and go to state 50


state 33

    (49) Block -> ID . ASSIGN Exp ;
    (50) Block -> ID . [ Exp ] ASSIGN Exp ;

    ASSIGN          shift and go to state 51
    [               shift and go to state 52


state 34

    (51) Block -> IF . Condition THEN Block
    (52) Block -> IF . Condition THEN Block ELSE Block
    (53) Block -> IF . Condition THEN BEGIN Blocks END ;
    (54) Block -> IF . Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (62) Condition -> . Condition OR CondTerm
    (63) Condition -> . CondTerm
    (64) CondTerm -> . CondTerm AND CondFactor
    (65) CondTerm -> . CondFactor
    (66) CondFactor -> . NOT CondFactor
    (67) CondFactor -> . Exp RelOp Exp
    (68) CondFactor -> . ( Condition )
    (69) CondFactor -> . TRUE
    (70) CondFactor -> . FALSE
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    NOT             shift and go to state 56
    (               shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    ID              shift and go to state 66

    Condition                      shift and go to state 53
    CondTerm                       shift and go to state 54
    CondFactor                     shift and go to state 55
    Exp                            shift and go to state 57
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 35

    (55) Block -> WHILE . Condition DO Block
    (56) Block -> WHILE . Condition DO BEGIN Blocks END ;
    (62) Condition -> . Condition OR CondTerm
    (63) Condition -> . CondTerm
    (64) CondTerm -> . CondTerm AND CondFactor
    (65) CondTerm -> . CondFactor
    (66) CondFactor -> . NOT CondFactor
    (67) CondFactor -> . Exp RelOp Exp
    (68) CondFactor -> . ( Condition )
    (69) CondFactor -> . TRUE
    (70) CondFactor -> . FALSE
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    NOT             shift and go to state 56
    (               shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    ID              shift and go to state 66

    Condition                      shift and go to state 67
    CondTerm                       shift and go to state 54
    CondFactor                     shift and go to state 55
    Exp                            shift and go to state 57
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 36

    (57) Block -> FOR . ID ASSIGN Exp TO Exp DO Block
    (58) Block -> FOR . ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> FOR . ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> FOR . ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;

    ID              shift and go to state 68


state 37

    (61) Block -> REPEAT . Blocks UNTIL Condition ;
    (38) Blocks -> . Block Blocks
    (39) Blocks -> .
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    UNTIL           reduce using rule 39 (Blocks -> .)
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Blocks                         shift and go to state 69
    Block                          shift and go to state 29

state 38

    (17) VarList -> IDList : . Type ; VarList
    (22) Type -> . INTEGER
    (23) Type -> . BOOLEAN
    (24) Type -> . STRING
    (25) Type -> . REALTYPE
    (26) Type -> . CHAR
    (27) Type -> . ARRAY [ INT DOTDOT INT ] OF Type

    INTEGER         shift and go to state 71
    BOOLEAN         shift and go to state 72
    STRING          shift and go to state 73
    REALTYPE        shift and go to state 74
    CHAR            shift and go to state 75
    ARRAY           shift and go to state 76

    Type                           shift and go to state 70

state 39

    (19) IDList -> ID RestoIDs .

    :               reduce using rule 19 (IDList -> ID RestoIDs .)


state 40

    (20) RestoIDs -> , . ID RestoIDs

    ID              shift and go to state 77


state 41

    (9) ConstDefs -> ID = . ConstValue ; ConstDefs
    (11) ConstValue -> . INT
    (12) ConstValue -> . REAL
    (13) ConstValue -> . STR
    (14) ConstValue -> . TRUE
    (15) ConstValue -> . FALSE

    INT             shift and go to state 79
    REAL            shift and go to state 80
    STR             shift and go to state 81
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    ConstValue                     shift and go to state 78

state 42

    (28) Functions -> FUNCTION ID ( . Parameters ) : Type ; FunctionBody
    (34) Parameters -> . IDList : Type MoreParameters
    (35) Parameters -> .
    (19) IDList -> . ID RestoIDs

    )               reduce using rule 35 (Parameters -> .)
    ID              shift and go to state 23

    Parameters                     shift and go to state 84
    IDList                         shift and go to state 85

state 43

    (29) Functions -> FUNCTION ID : . Type ; FunctionBody
    (22) Type -> . INTEGER
    (23) Type -> . BOOLEAN
    (24) Type -> . STRING
    (25) Type -> . REALTYPE
    (26) Type -> . CHAR
    (27) Type -> . ARRAY [ INT DOTDOT INT ] OF Type

    INTEGER         shift and go to state 71
    BOOLEAN         shift and go to state 72
    STRING          shift and go to state 73
    REALTYPE        shift and go to state 74
    CHAR            shift and go to state 75
    ARRAY           shift and go to state 76

    Type                           shift and go to state 86

state 44

    (31) Procedures -> PROCEDURE ID ( . Parameters ) ; ProcedureBody
    (34) Parameters -> . IDList : Type MoreParameters
    (35) Parameters -> .
    (19) IDList -> . ID RestoIDs

    )               reduce using rule 35 (Parameters -> .)
    ID              shift and go to state 23

    Parameters                     shift and go to state 87
    IDList                         shift and go to state 85

state 45

    (32) Procedures -> PROCEDURE ID ; . ProcedureBody
    (33) ProcedureBody -> . Declarations BEGIN Blocks END ;
    (3) Declarations -> . Vars Declarations
    (4) Declarations -> . Consts Declarations
    (5) Declarations -> . Functions Declarations
    (6) Declarations -> . Procedures Declarations
    (7) Declarations -> .
    (16) Vars -> . VAR VarList
    (8) Consts -> . CONST ConstDefs
    (28) Functions -> . FUNCTION ID ( Parameters ) : Type ; FunctionBody
    (29) Functions -> . FUNCTION ID : Type ; FunctionBody
    (31) Procedures -> . PROCEDURE ID ( Parameters ) ; ProcedureBody
    (32) Procedures -> . PROCEDURE ID ; ProcedureBody

    BEGIN           reduce using rule 7 (Declarations -> .)
    VAR             shift and go to state 11
    CONST           shift and go to state 12
    FUNCTION        shift and go to state 13
    PROCEDURE       shift and go to state 14

    ProcedureBody                  shift and go to state 88
    Declarations                   shift and go to state 89
    Vars                           shift and go to state 7
    Consts                         shift and go to state 8
    Functions                      shift and go to state 9
    Procedures                     shift and go to state 10

state 46

    (2) Code -> Declarations BEGIN Blocks END .

    .               reduce using rule 2 (Code -> Declarations BEGIN Blocks END .)


state 47

    (38) Blocks -> Block Blocks .

    END             reduce using rule 38 (Blocks -> Block Blocks .)
    UNTIL           reduce using rule 38 (Blocks -> Block Blocks .)


state 48

    (40) Block -> WRITELN ( . WriteList ) ;
    (42) WriteList -> . WriteItem MoreWriteItems
    (45) WriteItem -> . STR
    (46) WriteItem -> . Exp
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    STR             shift and go to state 93
    INT             shift and go to state 63
    REAL            shift and go to state 64
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    WriteList                      shift and go to state 91
    WriteItem                      shift and go to state 92
    Exp                            shift and go to state 94
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 49

    (41) Block -> WRITE ( . WriteList ) ;
    (42) WriteList -> . WriteItem MoreWriteItems
    (45) WriteItem -> . STR
    (46) WriteItem -> . Exp
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    STR             shift and go to state 93
    INT             shift and go to state 63
    REAL            shift and go to state 64
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    WriteList                      shift and go to state 97
    WriteItem                      shift and go to state 92
    Exp                            shift and go to state 94
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 50

    (47) Block -> READLN ( . ID ) ;
    (48) Block -> READLN ( . ID [ Exp ] ) ;

    ID              shift and go to state 98


state 51

    (49) Block -> ID ASSIGN . Exp ;
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 99
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 52

    (50) Block -> ID [ . Exp ] ASSIGN Exp ;
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 100
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 53

    (51) Block -> IF Condition . THEN Block
    (52) Block -> IF Condition . THEN Block ELSE Block
    (53) Block -> IF Condition . THEN BEGIN Blocks END ;
    (54) Block -> IF Condition . THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (62) Condition -> Condition . OR CondTerm

    THEN            shift and go to state 101
    OR              shift and go to state 102


state 54

    (63) Condition -> CondTerm .
    (64) CondTerm -> CondTerm . AND CondFactor

    THEN            reduce using rule 63 (Condition -> CondTerm .)
    OR              reduce using rule 63 (Condition -> CondTerm .)
    DO              reduce using rule 63 (Condition -> CondTerm .)
    )               reduce using rule 63 (Condition -> CondTerm .)
    ;               reduce using rule 63 (Condition -> CondTerm .)
    AND             shift and go to state 103


state 55

    (65) CondTerm -> CondFactor .

    AND             reduce using rule 65 (CondTerm -> CondFactor .)
    THEN            reduce using rule 65 (CondTerm -> CondFactor .)
    OR              reduce using rule 65 (CondTerm -> CondFactor .)
    DO              reduce using rule 65 (CondTerm -> CondFactor .)
    )               reduce using rule 65 (CondTerm -> CondFactor .)
    ;               reduce using rule 65 (CondTerm -> CondFactor .)


state 56

    (66) CondFactor -> NOT . CondFactor
    (66) CondFactor -> . NOT CondFactor
    (67) CondFactor -> . Exp RelOp Exp
    (68) CondFactor -> . ( Condition )
    (69) CondFactor -> . TRUE
    (70) CondFactor -> . FALSE
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    NOT             shift and go to state 56
    (               shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    ID              shift and go to state 66

    CondFactor                     shift and go to state 104
    Exp                            shift and go to state 57
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 57

    (67) CondFactor -> Exp . RelOp Exp
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term
    (71) RelOp -> . =
    (72) RelOp -> . NE
    (73) RelOp -> . <
    (74) RelOp -> . LE
    (75) RelOp -> . >
    (76) RelOp -> . GE

    +               shift and go to state 106
    -               shift and go to state 107
    =               shift and go to state 108
    NE              shift and go to state 109
    <               shift and go to state 110
    LE              shift and go to state 111
    >               shift and go to state 112
    GE              shift and go to state 113

    RelOp                          shift and go to state 105

state 58

    (68) CondFactor -> ( . Condition )
    (93) Factor -> ( . Exp )
    (62) Condition -> . Condition OR CondTerm
    (63) Condition -> . CondTerm
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (64) CondTerm -> . CondTerm AND CondFactor
    (65) CondTerm -> . CondFactor
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (66) CondFactor -> . NOT CondFactor
    (67) CondFactor -> . Exp RelOp Exp
    (68) CondFactor -> . ( Condition )
    (69) CondFactor -> . TRUE
    (70) CondFactor -> . FALSE
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    NOT             shift and go to state 56
    (               shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    ID              shift and go to state 66

    Condition                      shift and go to state 114
    Exp                            shift and go to state 115
    CondTerm                       shift and go to state 54
    Term                           shift and go to state 61
    CondFactor                     shift and go to state 55
    Factor                         shift and go to state 62

state 59

    (69) CondFactor -> TRUE .
    (88) Factor -> TRUE .

  ! reduce/reduce conflict for ) resolved using rule 69 (CondFactor -> TRUE .)
    AND             reduce using rule 69 (CondFactor -> TRUE .)
    THEN            reduce using rule 69 (CondFactor -> TRUE .)
    OR              reduce using rule 69 (CondFactor -> TRUE .)
    DO              reduce using rule 69 (CondFactor -> TRUE .)
    )               reduce using rule 69 (CondFactor -> TRUE .)
    ;               reduce using rule 69 (CondFactor -> TRUE .)
    *               reduce using rule 88 (Factor -> TRUE .)
    /               reduce using rule 88 (Factor -> TRUE .)
    DIV             reduce using rule 88 (Factor -> TRUE .)
    MOD             reduce using rule 88 (Factor -> TRUE .)
    +               reduce using rule 88 (Factor -> TRUE .)
    -               reduce using rule 88 (Factor -> TRUE .)
    =               reduce using rule 88 (Factor -> TRUE .)
    NE              reduce using rule 88 (Factor -> TRUE .)
    <               reduce using rule 88 (Factor -> TRUE .)
    LE              reduce using rule 88 (Factor -> TRUE .)
    >               reduce using rule 88 (Factor -> TRUE .)
    GE              reduce using rule 88 (Factor -> TRUE .)

  ! )               [ reduce using rule 88 (Factor -> TRUE .) ]


state 60

    (70) CondFactor -> FALSE .
    (89) Factor -> FALSE .

  ! reduce/reduce conflict for ) resolved using rule 70 (CondFactor -> FALSE .)
    AND             reduce using rule 70 (CondFactor -> FALSE .)
    THEN            reduce using rule 70 (CondFactor -> FALSE .)
    OR              reduce using rule 70 (CondFactor -> FALSE .)
    DO              reduce using rule 70 (CondFactor -> FALSE .)
    )               reduce using rule 70 (CondFactor -> FALSE .)
    ;               reduce using rule 70 (CondFactor -> FALSE .)
    *               reduce using rule 89 (Factor -> FALSE .)
    /               reduce using rule 89 (Factor -> FALSE .)
    DIV             reduce using rule 89 (Factor -> FALSE .)
    MOD             reduce using rule 89 (Factor -> FALSE .)
    +               reduce using rule 89 (Factor -> FALSE .)
    -               reduce using rule 89 (Factor -> FALSE .)
    =               reduce using rule 89 (Factor -> FALSE .)
    NE              reduce using rule 89 (Factor -> FALSE .)
    <               reduce using rule 89 (Factor -> FALSE .)
    LE              reduce using rule 89 (Factor -> FALSE .)
    >               reduce using rule 89 (Factor -> FALSE .)
    GE              reduce using rule 89 (Factor -> FALSE .)

  ! )               [ reduce using rule 89 (Factor -> FALSE .) ]


state 61

    (79) Exp -> Term .
    (80) Term -> Term . * Factor
    (81) Term -> Term . / Factor
    (82) Term -> Term . DIV Factor
    (83) Term -> Term . MOD Factor

    +               reduce using rule 79 (Exp -> Term .)
    -               reduce using rule 79 (Exp -> Term .)
    =               reduce using rule 79 (Exp -> Term .)
    NE              reduce using rule 79 (Exp -> Term .)
    <               reduce using rule 79 (Exp -> Term .)
    LE              reduce using rule 79 (Exp -> Term .)
    >               reduce using rule 79 (Exp -> Term .)
    GE              reduce using rule 79 (Exp -> Term .)
    ,               reduce using rule 79 (Exp -> Term .)
    )               reduce using rule 79 (Exp -> Term .)
    ;               reduce using rule 79 (Exp -> Term .)
    ]               reduce using rule 79 (Exp -> Term .)
    AND             reduce using rule 79 (Exp -> Term .)
    THEN            reduce using rule 79 (Exp -> Term .)
    OR              reduce using rule 79 (Exp -> Term .)
    DO              reduce using rule 79 (Exp -> Term .)
    TO              reduce using rule 79 (Exp -> Term .)
    DOWNTO          reduce using rule 79 (Exp -> Term .)
    *               shift and go to state 116
    /               shift and go to state 117
    DIV             shift and go to state 118
    MOD             shift and go to state 119


state 62

    (84) Term -> Factor .

    *               reduce using rule 84 (Term -> Factor .)
    /               reduce using rule 84 (Term -> Factor .)
    DIV             reduce using rule 84 (Term -> Factor .)
    MOD             reduce using rule 84 (Term -> Factor .)
    +               reduce using rule 84 (Term -> Factor .)
    -               reduce using rule 84 (Term -> Factor .)
    =               reduce using rule 84 (Term -> Factor .)
    NE              reduce using rule 84 (Term -> Factor .)
    <               reduce using rule 84 (Term -> Factor .)
    LE              reduce using rule 84 (Term -> Factor .)
    >               reduce using rule 84 (Term -> Factor .)
    GE              reduce using rule 84 (Term -> Factor .)
    ,               reduce using rule 84 (Term -> Factor .)
    )               reduce using rule 84 (Term -> Factor .)
    ;               reduce using rule 84 (Term -> Factor .)
    ]               reduce using rule 84 (Term -> Factor .)
    AND             reduce using rule 84 (Term -> Factor .)
    THEN            reduce using rule 84 (Term -> Factor .)
    OR              reduce using rule 84 (Term -> Factor .)
    DO              reduce using rule 84 (Term -> Factor .)
    TO              reduce using rule 84 (Term -> Factor .)
    DOWNTO          reduce using rule 84 (Term -> Factor .)


state 63

    (85) Factor -> INT .

    *               reduce using rule 85 (Factor -> INT .)
    /               reduce using rule 85 (Factor -> INT .)
    DIV             reduce using rule 85 (Factor -> INT .)
    MOD             reduce using rule 85 (Factor -> INT .)
    +               reduce using rule 85 (Factor -> INT .)
    -               reduce using rule 85 (Factor -> INT .)
    =               reduce using rule 85 (Factor -> INT .)
    NE              reduce using rule 85 (Factor -> INT .)
    <               reduce using rule 85 (Factor -> INT .)
    LE              reduce using rule 85 (Factor -> INT .)
    >               reduce using rule 85 (Factor -> INT .)
    GE              reduce using rule 85 (Factor -> INT .)
    ,               reduce using rule 85 (Factor -> INT .)
    )               reduce using rule 85 (Factor -> INT .)
    ;               reduce using rule 85 (Factor -> INT .)
    ]               reduce using rule 85 (Factor -> INT .)
    AND             reduce using rule 85 (Factor -> INT .)
    THEN            reduce using rule 85 (Factor -> INT .)
    OR              reduce using rule 85 (Factor -> INT .)
    DO              reduce using rule 85 (Factor -> INT .)
    TO              reduce using rule 85 (Factor -> INT .)
    DOWNTO          reduce using rule 85 (Factor -> INT .)


state 64

    (86) Factor -> REAL .

    *               reduce using rule 86 (Factor -> REAL .)
    /               reduce using rule 86 (Factor -> REAL .)
    DIV             reduce using rule 86 (Factor -> REAL .)
    MOD             reduce using rule 86 (Factor -> REAL .)
    +               reduce using rule 86 (Factor -> REAL .)
    -               reduce using rule 86 (Factor -> REAL .)
    =               reduce using rule 86 (Factor -> REAL .)
    NE              reduce using rule 86 (Factor -> REAL .)
    <               reduce using rule 86 (Factor -> REAL .)
    LE              reduce using rule 86 (Factor -> REAL .)
    >               reduce using rule 86 (Factor -> REAL .)
    GE              reduce using rule 86 (Factor -> REAL .)
    ,               reduce using rule 86 (Factor -> REAL .)
    )               reduce using rule 86 (Factor -> REAL .)
    ;               reduce using rule 86 (Factor -> REAL .)
    ]               reduce using rule 86 (Factor -> REAL .)
    AND             reduce using rule 86 (Factor -> REAL .)
    THEN            reduce using rule 86 (Factor -> REAL .)
    OR              reduce using rule 86 (Factor -> REAL .)
    DO              reduce using rule 86 (Factor -> REAL .)
    TO              reduce using rule 86 (Factor -> REAL .)
    DOWNTO          reduce using rule 86 (Factor -> REAL .)


state 65

    (87) Factor -> STR .

    *               reduce using rule 87 (Factor -> STR .)
    /               reduce using rule 87 (Factor -> STR .)
    DIV             reduce using rule 87 (Factor -> STR .)
    MOD             reduce using rule 87 (Factor -> STR .)
    +               reduce using rule 87 (Factor -> STR .)
    -               reduce using rule 87 (Factor -> STR .)
    =               reduce using rule 87 (Factor -> STR .)
    NE              reduce using rule 87 (Factor -> STR .)
    <               reduce using rule 87 (Factor -> STR .)
    LE              reduce using rule 87 (Factor -> STR .)
    >               reduce using rule 87 (Factor -> STR .)
    GE              reduce using rule 87 (Factor -> STR .)
    ;               reduce using rule 87 (Factor -> STR .)
    ]               reduce using rule 87 (Factor -> STR .)
    )               reduce using rule 87 (Factor -> STR .)
    AND             reduce using rule 87 (Factor -> STR .)
    THEN            reduce using rule 87 (Factor -> STR .)
    OR              reduce using rule 87 (Factor -> STR .)
    DO              reduce using rule 87 (Factor -> STR .)
    ,               reduce using rule 87 (Factor -> STR .)
    TO              reduce using rule 87 (Factor -> STR .)
    DOWNTO          reduce using rule 87 (Factor -> STR .)


state 66

    (90) Factor -> ID .
    (91) Factor -> ID . [ Exp ]
    (92) Factor -> ID . ( ArgumentList )

    *               reduce using rule 90 (Factor -> ID .)
    /               reduce using rule 90 (Factor -> ID .)
    DIV             reduce using rule 90 (Factor -> ID .)
    MOD             reduce using rule 90 (Factor -> ID .)
    +               reduce using rule 90 (Factor -> ID .)
    -               reduce using rule 90 (Factor -> ID .)
    =               reduce using rule 90 (Factor -> ID .)
    NE              reduce using rule 90 (Factor -> ID .)
    <               reduce using rule 90 (Factor -> ID .)
    LE              reduce using rule 90 (Factor -> ID .)
    >               reduce using rule 90 (Factor -> ID .)
    GE              reduce using rule 90 (Factor -> ID .)
    ,               reduce using rule 90 (Factor -> ID .)
    )               reduce using rule 90 (Factor -> ID .)
    ;               reduce using rule 90 (Factor -> ID .)
    ]               reduce using rule 90 (Factor -> ID .)
    AND             reduce using rule 90 (Factor -> ID .)
    THEN            reduce using rule 90 (Factor -> ID .)
    OR              reduce using rule 90 (Factor -> ID .)
    DO              reduce using rule 90 (Factor -> ID .)
    TO              reduce using rule 90 (Factor -> ID .)
    DOWNTO          reduce using rule 90 (Factor -> ID .)
    [               shift and go to state 120
    (               shift and go to state 121


state 67

    (55) Block -> WHILE Condition . DO Block
    (56) Block -> WHILE Condition . DO BEGIN Blocks END ;
    (62) Condition -> Condition . OR CondTerm

    DO              shift and go to state 122
    OR              shift and go to state 102


state 68

    (57) Block -> FOR ID . ASSIGN Exp TO Exp DO Block
    (58) Block -> FOR ID . ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> FOR ID . ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> FOR ID . ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;

    ASSIGN          shift and go to state 123


state 69

    (61) Block -> REPEAT Blocks . UNTIL Condition ;

    UNTIL           shift and go to state 124


state 70

    (17) VarList -> IDList : Type . ; VarList

    ;               shift and go to state 125


state 71

    (22) Type -> INTEGER .

    ;               reduce using rule 22 (Type -> INTEGER .)
    )               reduce using rule 22 (Type -> INTEGER .)


state 72

    (23) Type -> BOOLEAN .

    ;               reduce using rule 23 (Type -> BOOLEAN .)
    )               reduce using rule 23 (Type -> BOOLEAN .)


state 73

    (24) Type -> STRING .

    ;               reduce using rule 24 (Type -> STRING .)
    )               reduce using rule 24 (Type -> STRING .)


state 74

    (25) Type -> REALTYPE .

    ;               reduce using rule 25 (Type -> REALTYPE .)
    )               reduce using rule 25 (Type -> REALTYPE .)


state 75

    (26) Type -> CHAR .

    ;               reduce using rule 26 (Type -> CHAR .)
    )               reduce using rule 26 (Type -> CHAR .)


state 76

    (27) Type -> ARRAY . [ INT DOTDOT INT ] OF Type

    [               shift and go to state 126


state 77

    (20) RestoIDs -> , ID . RestoIDs
    (20) RestoIDs -> . , ID RestoIDs
    (21) RestoIDs -> .

    ,               shift and go to state 40
    :               reduce using rule 21 (RestoIDs -> .)

    RestoIDs                       shift and go to state 127

state 78

    (9) ConstDefs -> ID = ConstValue . ; ConstDefs

    ;               shift and go to state 128


state 79

    (11) ConstValue -> INT .

    ;               reduce using rule 11 (ConstValue -> INT .)


state 80

    (12) ConstValue -> REAL .

    ;               reduce using rule 12 (ConstValue -> REAL .)


state 81

    (13) ConstValue -> STR .

    ;               reduce using rule 13 (ConstValue -> STR .)


state 82

    (14) ConstValue -> TRUE .

    ;               reduce using rule 14 (ConstValue -> TRUE .)


state 83

    (15) ConstValue -> FALSE .

    ;               reduce using rule 15 (ConstValue -> FALSE .)


state 84

    (28) Functions -> FUNCTION ID ( Parameters . ) : Type ; FunctionBody

    )               shift and go to state 129


state 85

    (34) Parameters -> IDList . : Type MoreParameters

    :               shift and go to state 130


state 86

    (29) Functions -> FUNCTION ID : Type . ; FunctionBody

    ;               shift and go to state 131


state 87

    (31) Procedures -> PROCEDURE ID ( Parameters . ) ; ProcedureBody

    )               shift and go to state 132


state 88

    (32) Procedures -> PROCEDURE ID ; ProcedureBody .

    VAR             reduce using rule 32 (Procedures -> PROCEDURE ID ; ProcedureBody .)
    CONST           reduce using rule 32 (Procedures -> PROCEDURE ID ; ProcedureBody .)
    FUNCTION        reduce using rule 32 (Procedures -> PROCEDURE ID ; ProcedureBody .)
    PROCEDURE       reduce using rule 32 (Procedures -> PROCEDURE ID ; ProcedureBody .)
    BEGIN           reduce using rule 32 (Procedures -> PROCEDURE ID ; ProcedureBody .)


state 89

    (33) ProcedureBody -> Declarations . BEGIN Blocks END ;

    BEGIN           shift and go to state 133


state 90

    (93) Factor -> ( . Exp )
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 134
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 91

    (40) Block -> WRITELN ( WriteList . ) ;

    )               shift and go to state 135


state 92

    (42) WriteList -> WriteItem . MoreWriteItems
    (43) MoreWriteItems -> . , WriteItem MoreWriteItems
    (44) MoreWriteItems -> .

    ,               shift and go to state 137
    )               reduce using rule 44 (MoreWriteItems -> .)

    MoreWriteItems                 shift and go to state 136

state 93

    (45) WriteItem -> STR .
    (87) Factor -> STR .

  ! reduce/reduce conflict for , resolved using rule 45 (WriteItem -> STR .)
  ! reduce/reduce conflict for ) resolved using rule 45 (WriteItem -> STR .)
    ,               reduce using rule 45 (WriteItem -> STR .)
    )               reduce using rule 45 (WriteItem -> STR .)
    *               reduce using rule 87 (Factor -> STR .)
    /               reduce using rule 87 (Factor -> STR .)
    DIV             reduce using rule 87 (Factor -> STR .)
    MOD             reduce using rule 87 (Factor -> STR .)
    +               reduce using rule 87 (Factor -> STR .)
    -               reduce using rule 87 (Factor -> STR .)

  ! ,               [ reduce using rule 87 (Factor -> STR .) ]
  ! )               [ reduce using rule 87 (Factor -> STR .) ]


state 94

    (46) WriteItem -> Exp .
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    ,               reduce using rule 46 (WriteItem -> Exp .)
    )               reduce using rule 46 (WriteItem -> Exp .)
    +               shift and go to state 106
    -               shift and go to state 107


state 95

    (88) Factor -> TRUE .

    *               reduce using rule 88 (Factor -> TRUE .)
    /               reduce using rule 88 (Factor -> TRUE .)
    DIV             reduce using rule 88 (Factor -> TRUE .)
    MOD             reduce using rule 88 (Factor -> TRUE .)
    +               reduce using rule 88 (Factor -> TRUE .)
    -               reduce using rule 88 (Factor -> TRUE .)
    ,               reduce using rule 88 (Factor -> TRUE .)
    )               reduce using rule 88 (Factor -> TRUE .)
    ;               reduce using rule 88 (Factor -> TRUE .)
    ]               reduce using rule 88 (Factor -> TRUE .)
    AND             reduce using rule 88 (Factor -> TRUE .)
    THEN            reduce using rule 88 (Factor -> TRUE .)
    OR              reduce using rule 88 (Factor -> TRUE .)
    DO              reduce using rule 88 (Factor -> TRUE .)
    =               reduce using rule 88 (Factor -> TRUE .)
    NE              reduce using rule 88 (Factor -> TRUE .)
    <               reduce using rule 88 (Factor -> TRUE .)
    LE              reduce using rule 88 (Factor -> TRUE .)
    >               reduce using rule 88 (Factor -> TRUE .)
    GE              reduce using rule 88 (Factor -> TRUE .)
    TO              reduce using rule 88 (Factor -> TRUE .)
    DOWNTO          reduce using rule 88 (Factor -> TRUE .)


state 96

    (89) Factor -> FALSE .

    *               reduce using rule 89 (Factor -> FALSE .)
    /               reduce using rule 89 (Factor -> FALSE .)
    DIV             reduce using rule 89 (Factor -> FALSE .)
    MOD             reduce using rule 89 (Factor -> FALSE .)
    +               reduce using rule 89 (Factor -> FALSE .)
    -               reduce using rule 89 (Factor -> FALSE .)
    ,               reduce using rule 89 (Factor -> FALSE .)
    )               reduce using rule 89 (Factor -> FALSE .)
    ;               reduce using rule 89 (Factor -> FALSE .)
    ]               reduce using rule 89 (Factor -> FALSE .)
    AND             reduce using rule 89 (Factor -> FALSE .)
    THEN            reduce using rule 89 (Factor -> FALSE .)
    OR              reduce using rule 89 (Factor -> FALSE .)
    DO              reduce using rule 89 (Factor -> FALSE .)
    =               reduce using rule 89 (Factor -> FALSE .)
    NE              reduce using rule 89 (Factor -> FALSE .)
    <               reduce using rule 89 (Factor -> FALSE .)
    LE              reduce using rule 89 (Factor -> FALSE .)
    >               reduce using rule 89 (Factor -> FALSE .)
    GE              reduce using rule 89 (Factor -> FALSE .)
    TO              reduce using rule 89 (Factor -> FALSE .)
    DOWNTO          reduce using rule 89 (Factor -> FALSE .)


state 97

    (41) Block -> WRITE ( WriteList . ) ;

    )               shift and go to state 138


state 98

    (47) Block -> READLN ( ID . ) ;
    (48) Block -> READLN ( ID . [ Exp ] ) ;

    )               shift and go to state 139
    [               shift and go to state 140


state 99

    (49) Block -> ID ASSIGN Exp . ;
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    ;               shift and go to state 141
    +               shift and go to state 106
    -               shift and go to state 107


state 100

    (50) Block -> ID [ Exp . ] ASSIGN Exp ;
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    ]               shift and go to state 142
    +               shift and go to state 106
    -               shift and go to state 107


state 101

    (51) Block -> IF Condition THEN . Block
    (52) Block -> IF Condition THEN . Block ELSE Block
    (53) Block -> IF Condition THEN . BEGIN Blocks END ;
    (54) Block -> IF Condition THEN . BEGIN Blocks END ELSE BEGIN Blocks END ;
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    BEGIN           shift and go to state 144
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Block                          shift and go to state 143

state 102

    (62) Condition -> Condition OR . CondTerm
    (64) CondTerm -> . CondTerm AND CondFactor
    (65) CondTerm -> . CondFactor
    (66) CondFactor -> . NOT CondFactor
    (67) CondFactor -> . Exp RelOp Exp
    (68) CondFactor -> . ( Condition )
    (69) CondFactor -> . TRUE
    (70) CondFactor -> . FALSE
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    NOT             shift and go to state 56
    (               shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    ID              shift and go to state 66

    CondTerm                       shift and go to state 145
    CondFactor                     shift and go to state 55
    Exp                            shift and go to state 57
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 103

    (64) CondTerm -> CondTerm AND . CondFactor
    (66) CondFactor -> . NOT CondFactor
    (67) CondFactor -> . Exp RelOp Exp
    (68) CondFactor -> . ( Condition )
    (69) CondFactor -> . TRUE
    (70) CondFactor -> . FALSE
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    NOT             shift and go to state 56
    (               shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    ID              shift and go to state 66

    CondFactor                     shift and go to state 146
    Exp                            shift and go to state 57
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 104

    (66) CondFactor -> NOT CondFactor .

    AND             reduce using rule 66 (CondFactor -> NOT CondFactor .)
    THEN            reduce using rule 66 (CondFactor -> NOT CondFactor .)
    OR              reduce using rule 66 (CondFactor -> NOT CondFactor .)
    DO              reduce using rule 66 (CondFactor -> NOT CondFactor .)
    )               reduce using rule 66 (CondFactor -> NOT CondFactor .)
    ;               reduce using rule 66 (CondFactor -> NOT CondFactor .)


state 105

    (67) CondFactor -> Exp RelOp . Exp
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 147
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 106

    (77) Exp -> Exp + . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Term                           shift and go to state 148
    Factor                         shift and go to state 62

state 107

    (78) Exp -> Exp - . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Term                           shift and go to state 149
    Factor                         shift and go to state 62

state 108

    (71) RelOp -> = .

    INT             reduce using rule 71 (RelOp -> = .)
    REAL            reduce using rule 71 (RelOp -> = .)
    STR             reduce using rule 71 (RelOp -> = .)
    TRUE            reduce using rule 71 (RelOp -> = .)
    FALSE           reduce using rule 71 (RelOp -> = .)
    ID              reduce using rule 71 (RelOp -> = .)
    (               reduce using rule 71 (RelOp -> = .)


state 109

    (72) RelOp -> NE .

    INT             reduce using rule 72 (RelOp -> NE .)
    REAL            reduce using rule 72 (RelOp -> NE .)
    STR             reduce using rule 72 (RelOp -> NE .)
    TRUE            reduce using rule 72 (RelOp -> NE .)
    FALSE           reduce using rule 72 (RelOp -> NE .)
    ID              reduce using rule 72 (RelOp -> NE .)
    (               reduce using rule 72 (RelOp -> NE .)


state 110

    (73) RelOp -> < .

    INT             reduce using rule 73 (RelOp -> < .)
    REAL            reduce using rule 73 (RelOp -> < .)
    STR             reduce using rule 73 (RelOp -> < .)
    TRUE            reduce using rule 73 (RelOp -> < .)
    FALSE           reduce using rule 73 (RelOp -> < .)
    ID              reduce using rule 73 (RelOp -> < .)
    (               reduce using rule 73 (RelOp -> < .)


state 111

    (74) RelOp -> LE .

    INT             reduce using rule 74 (RelOp -> LE .)
    REAL            reduce using rule 74 (RelOp -> LE .)
    STR             reduce using rule 74 (RelOp -> LE .)
    TRUE            reduce using rule 74 (RelOp -> LE .)
    FALSE           reduce using rule 74 (RelOp -> LE .)
    ID              reduce using rule 74 (RelOp -> LE .)
    (               reduce using rule 74 (RelOp -> LE .)


state 112

    (75) RelOp -> > .

    INT             reduce using rule 75 (RelOp -> > .)
    REAL            reduce using rule 75 (RelOp -> > .)
    STR             reduce using rule 75 (RelOp -> > .)
    TRUE            reduce using rule 75 (RelOp -> > .)
    FALSE           reduce using rule 75 (RelOp -> > .)
    ID              reduce using rule 75 (RelOp -> > .)
    (               reduce using rule 75 (RelOp -> > .)


state 113

    (76) RelOp -> GE .

    INT             reduce using rule 76 (RelOp -> GE .)
    REAL            reduce using rule 76 (RelOp -> GE .)
    STR             reduce using rule 76 (RelOp -> GE .)
    TRUE            reduce using rule 76 (RelOp -> GE .)
    FALSE           reduce using rule 76 (RelOp -> GE .)
    ID              reduce using rule 76 (RelOp -> GE .)
    (               reduce using rule 76 (RelOp -> GE .)


state 114

    (68) CondFactor -> ( Condition . )
    (62) Condition -> Condition . OR CondTerm

    )               shift and go to state 150
    OR              shift and go to state 102


state 115

    (93) Factor -> ( Exp . )
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term
    (67) CondFactor -> Exp . RelOp Exp
    (71) RelOp -> . =
    (72) RelOp -> . NE
    (73) RelOp -> . <
    (74) RelOp -> . LE
    (75) RelOp -> . >
    (76) RelOp -> . GE

    )               shift and go to state 151
    +               shift and go to state 106
    -               shift and go to state 107
    =               shift and go to state 108
    NE              shift and go to state 109
    <               shift and go to state 110
    LE              shift and go to state 111
    >               shift and go to state 112
    GE              shift and go to state 113

    RelOp                          shift and go to state 105

state 116

    (80) Term -> Term * . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Factor                         shift and go to state 152

state 117

    (81) Term -> Term / . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Factor                         shift and go to state 153

state 118

    (82) Term -> Term DIV . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Factor                         shift and go to state 154

state 119

    (83) Term -> Term MOD . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Factor                         shift and go to state 155

state 120

    (91) Factor -> ID [ . Exp ]
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 156
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 121

    (92) Factor -> ID ( . ArgumentList )
    (94) ArgumentList -> . Exp MoreArguments
    (95) ArgumentList -> .
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    )               reduce using rule 95 (ArgumentList -> .)
    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    ArgumentList                   shift and go to state 157
    Exp                            shift and go to state 158
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 122

    (55) Block -> WHILE Condition DO . Block
    (56) Block -> WHILE Condition DO . BEGIN Blocks END ;
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    BEGIN           shift and go to state 160
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Block                          shift and go to state 159

state 123

    (57) Block -> FOR ID ASSIGN . Exp TO Exp DO Block
    (58) Block -> FOR ID ASSIGN . Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> FOR ID ASSIGN . Exp DOWNTO Exp DO Block
    (60) Block -> FOR ID ASSIGN . Exp DOWNTO Exp DO BEGIN Blocks END ;
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 161
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 124

    (61) Block -> REPEAT Blocks UNTIL . Condition ;
    (62) Condition -> . Condition OR CondTerm
    (63) Condition -> . CondTerm
    (64) CondTerm -> . CondTerm AND CondFactor
    (65) CondTerm -> . CondFactor
    (66) CondFactor -> . NOT CondFactor
    (67) CondFactor -> . Exp RelOp Exp
    (68) CondFactor -> . ( Condition )
    (69) CondFactor -> . TRUE
    (70) CondFactor -> . FALSE
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    NOT             shift and go to state 56
    (               shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    ID              shift and go to state 66

    Condition                      shift and go to state 162
    CondTerm                       shift and go to state 54
    CondFactor                     shift and go to state 55
    Exp                            shift and go to state 57
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 125

    (17) VarList -> IDList : Type ; . VarList
    (17) VarList -> . IDList : Type ; VarList
    (18) VarList -> .
    (19) IDList -> . ID RestoIDs

    VAR             reduce using rule 18 (VarList -> .)
    CONST           reduce using rule 18 (VarList -> .)
    FUNCTION        reduce using rule 18 (VarList -> .)
    PROCEDURE       reduce using rule 18 (VarList -> .)
    BEGIN           reduce using rule 18 (VarList -> .)
    ID              shift and go to state 23

    IDList                         shift and go to state 22
    VarList                        shift and go to state 163

state 126

    (27) Type -> ARRAY [ . INT DOTDOT INT ] OF Type

    INT             shift and go to state 164


state 127

    (20) RestoIDs -> , ID RestoIDs .

    :               reduce using rule 20 (RestoIDs -> , ID RestoIDs .)


state 128

    (9) ConstDefs -> ID = ConstValue ; . ConstDefs
    (9) ConstDefs -> . ID = ConstValue ; ConstDefs
    (10) ConstDefs -> .

    ID              shift and go to state 25
    VAR             reduce using rule 10 (ConstDefs -> .)
    CONST           reduce using rule 10 (ConstDefs -> .)
    FUNCTION        reduce using rule 10 (ConstDefs -> .)
    PROCEDURE       reduce using rule 10 (ConstDefs -> .)
    BEGIN           reduce using rule 10 (ConstDefs -> .)

    ConstDefs                      shift and go to state 165

state 129

    (28) Functions -> FUNCTION ID ( Parameters ) . : Type ; FunctionBody

    :               shift and go to state 166


state 130

    (34) Parameters -> IDList : . Type MoreParameters
    (22) Type -> . INTEGER
    (23) Type -> . BOOLEAN
    (24) Type -> . STRING
    (25) Type -> . REALTYPE
    (26) Type -> . CHAR
    (27) Type -> . ARRAY [ INT DOTDOT INT ] OF Type

    INTEGER         shift and go to state 71
    BOOLEAN         shift and go to state 72
    STRING          shift and go to state 73
    REALTYPE        shift and go to state 74
    CHAR            shift and go to state 75
    ARRAY           shift and go to state 76

    Type                           shift and go to state 167

state 131

    (29) Functions -> FUNCTION ID : Type ; . FunctionBody
    (30) FunctionBody -> . Declarations BEGIN Blocks END ;
    (3) Declarations -> . Vars Declarations
    (4) Declarations -> . Consts Declarations
    (5) Declarations -> . Functions Declarations
    (6) Declarations -> . Procedures Declarations
    (7) Declarations -> .
    (16) Vars -> . VAR VarList
    (8) Consts -> . CONST ConstDefs
    (28) Functions -> . FUNCTION ID ( Parameters ) : Type ; FunctionBody
    (29) Functions -> . FUNCTION ID : Type ; FunctionBody
    (31) Procedures -> . PROCEDURE ID ( Parameters ) ; ProcedureBody
    (32) Procedures -> . PROCEDURE ID ; ProcedureBody

    BEGIN           reduce using rule 7 (Declarations -> .)
    VAR             shift and go to state 11
    CONST           shift and go to state 12
    FUNCTION        shift and go to state 13
    PROCEDURE       shift and go to state 14

    FunctionBody                   shift and go to state 168
    Declarations                   shift and go to state 169
    Vars                           shift and go to state 7
    Consts                         shift and go to state 8
    Functions                      shift and go to state 9
    Procedures                     shift and go to state 10

state 132

    (31) Procedures -> PROCEDURE ID ( Parameters ) . ; ProcedureBody

    ;               shift and go to state 170


state 133

    (33) ProcedureBody -> Declarations BEGIN . Blocks END ;
    (38) Blocks -> . Block Blocks
    (39) Blocks -> .
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    END             reduce using rule 39 (Blocks -> .)
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Blocks                         shift and go to state 171
    Block                          shift and go to state 29

state 134

    (93) Factor -> ( Exp . )
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    )               shift and go to state 151
    +               shift and go to state 106
    -               shift and go to state 107


state 135

    (40) Block -> WRITELN ( WriteList ) . ;

    ;               shift and go to state 172


state 136

    (42) WriteList -> WriteItem MoreWriteItems .

    )               reduce using rule 42 (WriteList -> WriteItem MoreWriteItems .)


state 137

    (43) MoreWriteItems -> , . WriteItem MoreWriteItems
    (45) WriteItem -> . STR
    (46) WriteItem -> . Exp
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    STR             shift and go to state 93
    INT             shift and go to state 63
    REAL            shift and go to state 64
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    WriteItem                      shift and go to state 173
    Exp                            shift and go to state 94
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 138

    (41) Block -> WRITE ( WriteList ) . ;

    ;               shift and go to state 174


state 139

    (47) Block -> READLN ( ID ) . ;

    ;               shift and go to state 175


state 140

    (48) Block -> READLN ( ID [ . Exp ] ) ;
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 176
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 141

    (49) Block -> ID ASSIGN Exp ; .

    WRITELN         reduce using rule 49 (Block -> ID ASSIGN Exp ; .)
    WRITE           reduce using rule 49 (Block -> ID ASSIGN Exp ; .)
    READLN          reduce using rule 49 (Block -> ID ASSIGN Exp ; .)
    ID              reduce using rule 49 (Block -> ID ASSIGN Exp ; .)
    IF              reduce using rule 49 (Block -> ID ASSIGN Exp ; .)
    WHILE           reduce using rule 49 (Block -> ID ASSIGN Exp ; .)
    FOR             reduce using rule 49 (Block -> ID ASSIGN Exp ; .)
    REPEAT          reduce using rule 49 (Block -> ID ASSIGN Exp ; .)
    END             reduce using rule 49 (Block -> ID ASSIGN Exp ; .)
    UNTIL           reduce using rule 49 (Block -> ID ASSIGN Exp ; .)
    ELSE            reduce using rule 49 (Block -> ID ASSIGN Exp ; .)


state 142

    (50) Block -> ID [ Exp ] . ASSIGN Exp ;

    ASSIGN          shift and go to state 177


state 143

    (51) Block -> IF Condition THEN Block .
    (52) Block -> IF Condition THEN Block . ELSE Block

  ! shift/reduce conflict for ELSE resolved as shift
    WRITELN         reduce using rule 51 (Block -> IF Condition THEN Block .)
    WRITE           reduce using rule 51 (Block -> IF Condition THEN Block .)
    READLN          reduce using rule 51 (Block -> IF Condition THEN Block .)
    ID              reduce using rule 51 (Block -> IF Condition THEN Block .)
    IF              reduce using rule 51 (Block -> IF Condition THEN Block .)
    WHILE           reduce using rule 51 (Block -> IF Condition THEN Block .)
    FOR             reduce using rule 51 (Block -> IF Condition THEN Block .)
    REPEAT          reduce using rule 51 (Block -> IF Condition THEN Block .)
    END             reduce using rule 51 (Block -> IF Condition THEN Block .)
    UNTIL           reduce using rule 51 (Block -> IF Condition THEN Block .)
    ELSE            shift and go to state 178

  ! ELSE            [ reduce using rule 51 (Block -> IF Condition THEN Block .) ]


state 144

    (53) Block -> IF Condition THEN BEGIN . Blocks END ;
    (54) Block -> IF Condition THEN BEGIN . Blocks END ELSE BEGIN Blocks END ;
    (38) Blocks -> . Block Blocks
    (39) Blocks -> .
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    END             reduce using rule 39 (Blocks -> .)
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Blocks                         shift and go to state 179
    Block                          shift and go to state 29

state 145

    (62) Condition -> Condition OR CondTerm .
    (64) CondTerm -> CondTerm . AND CondFactor

    THEN            reduce using rule 62 (Condition -> Condition OR CondTerm .)
    OR              reduce using rule 62 (Condition -> Condition OR CondTerm .)
    DO              reduce using rule 62 (Condition -> Condition OR CondTerm .)
    )               reduce using rule 62 (Condition -> Condition OR CondTerm .)
    ;               reduce using rule 62 (Condition -> Condition OR CondTerm .)
    AND             shift and go to state 103


state 146

    (64) CondTerm -> CondTerm AND CondFactor .

    AND             reduce using rule 64 (CondTerm -> CondTerm AND CondFactor .)
    THEN            reduce using rule 64 (CondTerm -> CondTerm AND CondFactor .)
    OR              reduce using rule 64 (CondTerm -> CondTerm AND CondFactor .)
    DO              reduce using rule 64 (CondTerm -> CondTerm AND CondFactor .)
    )               reduce using rule 64 (CondTerm -> CondTerm AND CondFactor .)
    ;               reduce using rule 64 (CondTerm -> CondTerm AND CondFactor .)


state 147

    (67) CondFactor -> Exp RelOp Exp .
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    AND             reduce using rule 67 (CondFactor -> Exp RelOp Exp .)
    THEN            reduce using rule 67 (CondFactor -> Exp RelOp Exp .)
    OR              reduce using rule 67 (CondFactor -> Exp RelOp Exp .)
    DO              reduce using rule 67 (CondFactor -> Exp RelOp Exp .)
    )               reduce using rule 67 (CondFactor -> Exp RelOp Exp .)
    ;               reduce using rule 67 (CondFactor -> Exp RelOp Exp .)
    +               shift and go to state 106
    -               shift and go to state 107


state 148

    (77) Exp -> Exp + Term .
    (80) Term -> Term . * Factor
    (81) Term -> Term . / Factor
    (82) Term -> Term . DIV Factor
    (83) Term -> Term . MOD Factor

    +               reduce using rule 77 (Exp -> Exp + Term .)
    -               reduce using rule 77 (Exp -> Exp + Term .)
    =               reduce using rule 77 (Exp -> Exp + Term .)
    NE              reduce using rule 77 (Exp -> Exp + Term .)
    <               reduce using rule 77 (Exp -> Exp + Term .)
    LE              reduce using rule 77 (Exp -> Exp + Term .)
    >               reduce using rule 77 (Exp -> Exp + Term .)
    GE              reduce using rule 77 (Exp -> Exp + Term .)
    ,               reduce using rule 77 (Exp -> Exp + Term .)
    )               reduce using rule 77 (Exp -> Exp + Term .)
    ;               reduce using rule 77 (Exp -> Exp + Term .)
    ]               reduce using rule 77 (Exp -> Exp + Term .)
    AND             reduce using rule 77 (Exp -> Exp + Term .)
    THEN            reduce using rule 77 (Exp -> Exp + Term .)
    OR              reduce using rule 77 (Exp -> Exp + Term .)
    DO              reduce using rule 77 (Exp -> Exp + Term .)
    TO              reduce using rule 77 (Exp -> Exp + Term .)
    DOWNTO          reduce using rule 77 (Exp -> Exp + Term .)
    *               shift and go to state 116
    /               shift and go to state 117
    DIV             shift and go to state 118
    MOD             shift and go to state 119


state 149

    (78) Exp -> Exp - Term .
    (80) Term -> Term . * Factor
    (81) Term -> Term . / Factor
    (82) Term -> Term . DIV Factor
    (83) Term -> Term . MOD Factor

    +               reduce using rule 78 (Exp -> Exp - Term .)
    -               reduce using rule 78 (Exp -> Exp - Term .)
    =               reduce using rule 78 (Exp -> Exp - Term .)
    NE              reduce using rule 78 (Exp -> Exp - Term .)
    <               reduce using rule 78 (Exp -> Exp - Term .)
    LE              reduce using rule 78 (Exp -> Exp - Term .)
    >               reduce using rule 78 (Exp -> Exp - Term .)
    GE              reduce using rule 78 (Exp -> Exp - Term .)
    ,               reduce using rule 78 (Exp -> Exp - Term .)
    )               reduce using rule 78 (Exp -> Exp - Term .)
    ;               reduce using rule 78 (Exp -> Exp - Term .)
    ]               reduce using rule 78 (Exp -> Exp - Term .)
    AND             reduce using rule 78 (Exp -> Exp - Term .)
    THEN            reduce using rule 78 (Exp -> Exp - Term .)
    OR              reduce using rule 78 (Exp -> Exp - Term .)
    DO              reduce using rule 78 (Exp -> Exp - Term .)
    TO              reduce using rule 78 (Exp -> Exp - Term .)
    DOWNTO          reduce using rule 78 (Exp -> Exp - Term .)
    *               shift and go to state 116
    /               shift and go to state 117
    DIV             shift and go to state 118
    MOD             shift and go to state 119


state 150

    (68) CondFactor -> ( Condition ) .

    AND             reduce using rule 68 (CondFactor -> ( Condition ) .)
    THEN            reduce using rule 68 (CondFactor -> ( Condition ) .)
    OR              reduce using rule 68 (CondFactor -> ( Condition ) .)
    DO              reduce using rule 68 (CondFactor -> ( Condition ) .)
    )               reduce using rule 68 (CondFactor -> ( Condition ) .)
    ;               reduce using rule 68 (CondFactor -> ( Condition ) .)


state 151

    (93) Factor -> ( Exp ) .

    *               reduce using rule 93 (Factor -> ( Exp ) .)
    /               reduce using rule 93 (Factor -> ( Exp ) .)
    DIV             reduce using rule 93 (Factor -> ( Exp ) .)
    MOD             reduce using rule 93 (Factor -> ( Exp ) .)
    +               reduce using rule 93 (Factor -> ( Exp ) .)
    -               reduce using rule 93 (Factor -> ( Exp ) .)
    =               reduce using rule 93 (Factor -> ( Exp ) .)
    NE              reduce using rule 93 (Factor -> ( Exp ) .)
    <               reduce using rule 93 (Factor -> ( Exp ) .)
    LE              reduce using rule 93 (Factor -> ( Exp ) .)
    >               reduce using rule 93 (Factor -> ( Exp ) .)
    GE              reduce using rule 93 (Factor -> ( Exp ) .)
    ,               reduce using rule 93 (Factor -> ( Exp ) .)
    )               reduce using rule 93 (Factor -> ( Exp ) .)
    ;               reduce using rule 93 (Factor -> ( Exp ) .)
    ]               reduce using rule 93 (Factor -> ( Exp ) .)
    AND             reduce using rule 93 (Factor -> ( Exp ) .)
    THEN            reduce using rule 93 (Factor -> ( Exp ) .)
    OR              reduce using rule 93 (Factor -> ( Exp ) .)
    DO              reduce using rule 93 (Factor -> ( Exp ) .)
    TO              reduce using rule 93 (Factor -> ( Exp ) .)
    DOWNTO          reduce using rule 93 (Factor -> ( Exp ) .)


state 152

    (80) Term -> Term * Factor .

    *               reduce using rule 80 (Term -> Term * Factor .)
    /               reduce using rule 80 (Term -> Term * Factor .)
    DIV             reduce using rule 80 (Term -> Term * Factor .)
    MOD             reduce using rule 80 (Term -> Term * Factor .)
    +               reduce using rule 80 (Term -> Term * Factor .)
    -               reduce using rule 80 (Term -> Term * Factor .)
    =               reduce using rule 80 (Term -> Term * Factor .)
    NE              reduce using rule 80 (Term -> Term * Factor .)
    <               reduce using rule 80 (Term -> Term * Factor .)
    LE              reduce using rule 80 (Term -> Term * Factor .)
    >               reduce using rule 80 (Term -> Term * Factor .)
    GE              reduce using rule 80 (Term -> Term * Factor .)
    ,               reduce using rule 80 (Term -> Term * Factor .)
    )               reduce using rule 80 (Term -> Term * Factor .)
    ;               reduce using rule 80 (Term -> Term * Factor .)
    ]               reduce using rule 80 (Term -> Term * Factor .)
    AND             reduce using rule 80 (Term -> Term * Factor .)
    THEN            reduce using rule 80 (Term -> Term * Factor .)
    OR              reduce using rule 80 (Term -> Term * Factor .)
    DO              reduce using rule 80 (Term -> Term * Factor .)
    TO              reduce using rule 80 (Term -> Term * Factor .)
    DOWNTO          reduce using rule 80 (Term -> Term * Factor .)


state 153

    (81) Term -> Term / Factor .

    *               reduce using rule 81 (Term -> Term / Factor .)
    /               reduce using rule 81 (Term -> Term / Factor .)
    DIV             reduce using rule 81 (Term -> Term / Factor .)
    MOD             reduce using rule 81 (Term -> Term / Factor .)
    +               reduce using rule 81 (Term -> Term / Factor .)
    -               reduce using rule 81 (Term -> Term / Factor .)
    =               reduce using rule 81 (Term -> Term / Factor .)
    NE              reduce using rule 81 (Term -> Term / Factor .)
    <               reduce using rule 81 (Term -> Term / Factor .)
    LE              reduce using rule 81 (Term -> Term / Factor .)
    >               reduce using rule 81 (Term -> Term / Factor .)
    GE              reduce using rule 81 (Term -> Term / Factor .)
    ,               reduce using rule 81 (Term -> Term / Factor .)
    )               reduce using rule 81 (Term -> Term / Factor .)
    ;               reduce using rule 81 (Term -> Term / Factor .)
    ]               reduce using rule 81 (Term -> Term / Factor .)
    AND             reduce using rule 81 (Term -> Term / Factor .)
    THEN            reduce using rule 81 (Term -> Term / Factor .)
    OR              reduce using rule 81 (Term -> Term / Factor .)
    DO              reduce using rule 81 (Term -> Term / Factor .)
    TO              reduce using rule 81 (Term -> Term / Factor .)
    DOWNTO          reduce using rule 81 (Term -> Term / Factor .)


state 154

    (82) Term -> Term DIV Factor .

    *               reduce using rule 82 (Term -> Term DIV Factor .)
    /               reduce using rule 82 (Term -> Term DIV Factor .)
    DIV             reduce using rule 82 (Term -> Term DIV Factor .)
    MOD             reduce using rule 82 (Term -> Term DIV Factor .)
    +               reduce using rule 82 (Term -> Term DIV Factor .)
    -               reduce using rule 82 (Term -> Term DIV Factor .)
    =               reduce using rule 82 (Term -> Term DIV Factor .)
    NE              reduce using rule 82 (Term -> Term DIV Factor .)
    <               reduce using rule 82 (Term -> Term DIV Factor .)
    LE              reduce using rule 82 (Term -> Term DIV Factor .)
    >               reduce using rule 82 (Term -> Term DIV Factor .)
    GE              reduce using rule 82 (Term -> Term DIV Factor .)
    ,               reduce using rule 82 (Term -> Term DIV Factor .)
    )               reduce using rule 82 (Term -> Term DIV Factor .)
    ;               reduce using rule 82 (Term -> Term DIV Factor .)
    ]               reduce using rule 82 (Term -> Term DIV Factor .)
    AND             reduce using rule 82 (Term -> Term DIV Factor .)
    THEN            reduce using rule 82 (Term -> Term DIV Factor .)
    OR              reduce using rule 82 (Term -> Term DIV Factor .)
    DO              reduce using rule 82 (Term -> Term DIV Factor .)
    TO              reduce using rule 82 (Term -> Term DIV Factor .)
    DOWNTO          reduce using rule 82 (Term -> Term DIV Factor .)


state 155

    (83) Term -> Term MOD Factor .

    *               reduce using rule 83 (Term -> Term MOD Factor .)
    /               reduce using rule 83 (Term -> Term MOD Factor .)
    DIV             reduce using rule 83 (Term -> Term MOD Factor .)
    MOD             reduce using rule 83 (Term -> Term MOD Factor .)
    +               reduce using rule 83 (Term -> Term MOD Factor .)
    -               reduce using rule 83 (Term -> Term MOD Factor .)
    =               reduce using rule 83 (Term -> Term MOD Factor .)
    NE              reduce using rule 83 (Term -> Term MOD Factor .)
    <               reduce using rule 83 (Term -> Term MOD Factor .)
    LE              reduce using rule 83 (Term -> Term MOD Factor .)
    >               reduce using rule 83 (Term -> Term MOD Factor .)
    GE              reduce using rule 83 (Term -> Term MOD Factor .)
    ,               reduce using rule 83 (Term -> Term MOD Factor .)
    )               reduce using rule 83 (Term -> Term MOD Factor .)
    ;               reduce using rule 83 (Term -> Term MOD Factor .)
    ]               reduce using rule 83 (Term -> Term MOD Factor .)
    AND             reduce using rule 83 (Term -> Term MOD Factor .)
    THEN            reduce using rule 83 (Term -> Term MOD Factor .)
    OR              reduce using rule 83 (Term -> Term MOD Factor .)
    DO              reduce using rule 83 (Term -> Term MOD Factor .)
    TO              reduce using rule 83 (Term -> Term MOD Factor .)
    DOWNTO          reduce using rule 83 (Term -> Term MOD Factor .)


state 156

    (91) Factor -> ID [ Exp . ]
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    ]               shift and go to state 180
    +               shift and go to state 106
    -               shift and go to state 107


state 157

    (92) Factor -> ID ( ArgumentList . )

    )               shift and go to state 181


state 158

    (94) ArgumentList -> Exp . MoreArguments
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term
    (96) MoreArguments -> . , Exp MoreArguments
    (97) MoreArguments -> .

    +               shift and go to state 106
    -               shift and go to state 107
    ,               shift and go to state 183
    )               reduce using rule 97 (MoreArguments -> .)

    MoreArguments                  shift and go to state 182

state 159

    (55) Block -> WHILE Condition DO Block .

    WRITELN         reduce using rule 55 (Block -> WHILE Condition DO Block .)
    WRITE           reduce using rule 55 (Block -> WHILE Condition DO Block .)
    READLN          reduce using rule 55 (Block -> WHILE Condition DO Block .)
    ID              reduce using rule 55 (Block -> WHILE Condition DO Block .)
    IF              reduce using rule 55 (Block -> WHILE Condition DO Block .)
    WHILE           reduce using rule 55 (Block -> WHILE Condition DO Block .)
    FOR             reduce using rule 55 (Block -> WHILE Condition DO Block .)
    REPEAT          reduce using rule 55 (Block -> WHILE Condition DO Block .)
    END             reduce using rule 55 (Block -> WHILE Condition DO Block .)
    UNTIL           reduce using rule 55 (Block -> WHILE Condition DO Block .)
    ELSE            reduce using rule 55 (Block -> WHILE Condition DO Block .)


state 160

    (56) Block -> WHILE Condition DO BEGIN . Blocks END ;
    (38) Blocks -> . Block Blocks
    (39) Blocks -> .
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    END             reduce using rule 39 (Blocks -> .)
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Blocks                         shift and go to state 184
    Block                          shift and go to state 29

state 161

    (57) Block -> FOR ID ASSIGN Exp . TO Exp DO Block
    (58) Block -> FOR ID ASSIGN Exp . TO Exp DO BEGIN Blocks END ;
    (59) Block -> FOR ID ASSIGN Exp . DOWNTO Exp DO Block
    (60) Block -> FOR ID ASSIGN Exp . DOWNTO Exp DO BEGIN Blocks END ;
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    TO              shift and go to state 185
    DOWNTO          shift and go to state 186
    +               shift and go to state 106
    -               shift and go to state 107


state 162

    (61) Block -> REPEAT Blocks UNTIL Condition . ;
    (62) Condition -> Condition . OR CondTerm

    ;               shift and go to state 187
    OR              shift and go to state 102


state 163

    (17) VarList -> IDList : Type ; VarList .

    VAR             reduce using rule 17 (VarList -> IDList : Type ; VarList .)
    CONST           reduce using rule 17 (VarList -> IDList : Type ; VarList .)
    FUNCTION        reduce using rule 17 (VarList -> IDList : Type ; VarList .)
    PROCEDURE       reduce using rule 17 (VarList -> IDList : Type ; VarList .)
    BEGIN           reduce using rule 17 (VarList -> IDList : Type ; VarList .)


state 164

    (27) Type -> ARRAY [ INT . DOTDOT INT ] OF Type

    DOTDOT          shift and go to state 188


state 165

    (9) ConstDefs -> ID = ConstValue ; ConstDefs .

    VAR             reduce using rule 9 (ConstDefs -> ID = ConstValue ; ConstDefs .)
    CONST           reduce using rule 9 (ConstDefs -> ID = ConstValue ; ConstDefs .)
    FUNCTION        reduce using rule 9 (ConstDefs -> ID = ConstValue ; ConstDefs .)
    PROCEDURE       reduce using rule 9 (ConstDefs -> ID = ConstValue ; ConstDefs .)
    BEGIN           reduce using rule 9 (ConstDefs -> ID = ConstValue ; ConstDefs .)


state 166

    (28) Functions -> FUNCTION ID ( Parameters ) : . Type ; FunctionBody
    (22) Type -> . INTEGER
    (23) Type -> . BOOLEAN
    (24) Type -> . STRING
    (25) Type -> . REALTYPE
    (26) Type -> . CHAR
    (27) Type -> . ARRAY [ INT DOTDOT INT ] OF Type

    INTEGER         shift and go to state 71
    BOOLEAN         shift and go to state 72
    STRING          shift and go to state 73
    REALTYPE        shift and go to state 74
    CHAR            shift and go to state 75
    ARRAY           shift and go to state 76

    Type                           shift and go to state 189

state 167

    (34) Parameters -> IDList : Type . MoreParameters
    (36) MoreParameters -> . ; IDList : Type MoreParameters
    (37) MoreParameters -> .

    ;               shift and go to state 191
    )               reduce using rule 37 (MoreParameters -> .)

    MoreParameters                 shift and go to state 190

state 168

    (29) Functions -> FUNCTION ID : Type ; FunctionBody .

    VAR             reduce using rule 29 (Functions -> FUNCTION ID : Type ; FunctionBody .)
    CONST           reduce using rule 29 (Functions -> FUNCTION ID : Type ; FunctionBody .)
    FUNCTION        reduce using rule 29 (Functions -> FUNCTION ID : Type ; FunctionBody .)
    PROCEDURE       reduce using rule 29 (Functions -> FUNCTION ID : Type ; FunctionBody .)
    BEGIN           reduce using rule 29 (Functions -> FUNCTION ID : Type ; FunctionBody .)


state 169

    (30) FunctionBody -> Declarations . BEGIN Blocks END ;

    BEGIN           shift and go to state 192


state 170

    (31) Procedures -> PROCEDURE ID ( Parameters ) ; . ProcedureBody
    (33) ProcedureBody -> . Declarations BEGIN Blocks END ;
    (3) Declarations -> . Vars Declarations
    (4) Declarations -> . Consts Declarations
    (5) Declarations -> . Functions Declarations
    (6) Declarations -> . Procedures Declarations
    (7) Declarations -> .
    (16) Vars -> . VAR VarList
    (8) Consts -> . CONST ConstDefs
    (28) Functions -> . FUNCTION ID ( Parameters ) : Type ; FunctionBody
    (29) Functions -> . FUNCTION ID : Type ; FunctionBody
    (31) Procedures -> . PROCEDURE ID ( Parameters ) ; ProcedureBody
    (32) Procedures -> . PROCEDURE ID ; ProcedureBody

    BEGIN           reduce using rule 7 (Declarations -> .)
    VAR             shift and go to state 11
    CONST           shift and go to state 12
    FUNCTION        shift and go to state 13
    PROCEDURE       shift and go to state 14

    ProcedureBody                  shift and go to state 193
    Declarations                   shift and go to state 89
    Vars                           shift and go to state 7
    Consts                         shift and go to state 8
    Functions                      shift and go to state 9
    Procedures                     shift and go to state 10

state 171

    (33) ProcedureBody -> Declarations BEGIN Blocks . END ;

    END             shift and go to state 194


state 172

    (40) Block -> WRITELN ( WriteList ) ; .

    WRITELN         reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)
    WRITE           reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)
    READLN          reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)
    ID              reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)
    IF              reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)
    WHILE           reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)
    FOR             reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)
    REPEAT          reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)
    END             reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)
    UNTIL           reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)
    ELSE            reduce using rule 40 (Block -> WRITELN ( WriteList ) ; .)


state 173

    (43) MoreWriteItems -> , WriteItem . MoreWriteItems
    (43) MoreWriteItems -> . , WriteItem MoreWriteItems
    (44) MoreWriteItems -> .

    ,               shift and go to state 137
    )               reduce using rule 44 (MoreWriteItems -> .)

    MoreWriteItems                 shift and go to state 195

state 174

    (41) Block -> WRITE ( WriteList ) ; .

    WRITELN         reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)
    WRITE           reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)
    READLN          reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)
    ID              reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)
    IF              reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)
    WHILE           reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)
    FOR             reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)
    REPEAT          reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)
    END             reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)
    UNTIL           reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)
    ELSE            reduce using rule 41 (Block -> WRITE ( WriteList ) ; .)


state 175

    (47) Block -> READLN ( ID ) ; .

    WRITELN         reduce using rule 47 (Block -> READLN ( ID ) ; .)
    WRITE           reduce using rule 47 (Block -> READLN ( ID ) ; .)
    READLN          reduce using rule 47 (Block -> READLN ( ID ) ; .)
    ID              reduce using rule 47 (Block -> READLN ( ID ) ; .)
    IF              reduce using rule 47 (Block -> READLN ( ID ) ; .)
    WHILE           reduce using rule 47 (Block -> READLN ( ID ) ; .)
    FOR             reduce using rule 47 (Block -> READLN ( ID ) ; .)
    REPEAT          reduce using rule 47 (Block -> READLN ( ID ) ; .)
    END             reduce using rule 47 (Block -> READLN ( ID ) ; .)
    UNTIL           reduce using rule 47 (Block -> READLN ( ID ) ; .)
    ELSE            reduce using rule 47 (Block -> READLN ( ID ) ; .)


state 176

    (48) Block -> READLN ( ID [ Exp . ] ) ;
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    ]               shift and go to state 196
    +               shift and go to state 106
    -               shift and go to state 107


state 177

    (50) Block -> ID [ Exp ] ASSIGN . Exp ;
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 197
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 178

    (52) Block -> IF Condition THEN Block ELSE . Block
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Block                          shift and go to state 198

state 179

    (53) Block -> IF Condition THEN BEGIN Blocks . END ;
    (54) Block -> IF Condition THEN BEGIN Blocks . END ELSE BEGIN Blocks END ;

    END             shift and go to state 199


state 180

    (91) Factor -> ID [ Exp ] .

    *               reduce using rule 91 (Factor -> ID [ Exp ] .)
    /               reduce using rule 91 (Factor -> ID [ Exp ] .)
    DIV             reduce using rule 91 (Factor -> ID [ Exp ] .)
    MOD             reduce using rule 91 (Factor -> ID [ Exp ] .)
    +               reduce using rule 91 (Factor -> ID [ Exp ] .)
    -               reduce using rule 91 (Factor -> ID [ Exp ] .)
    =               reduce using rule 91 (Factor -> ID [ Exp ] .)
    NE              reduce using rule 91 (Factor -> ID [ Exp ] .)
    <               reduce using rule 91 (Factor -> ID [ Exp ] .)
    LE              reduce using rule 91 (Factor -> ID [ Exp ] .)
    >               reduce using rule 91 (Factor -> ID [ Exp ] .)
    GE              reduce using rule 91 (Factor -> ID [ Exp ] .)
    ,               reduce using rule 91 (Factor -> ID [ Exp ] .)
    )               reduce using rule 91 (Factor -> ID [ Exp ] .)
    ;               reduce using rule 91 (Factor -> ID [ Exp ] .)
    ]               reduce using rule 91 (Factor -> ID [ Exp ] .)
    AND             reduce using rule 91 (Factor -> ID [ Exp ] .)
    THEN            reduce using rule 91 (Factor -> ID [ Exp ] .)
    OR              reduce using rule 91 (Factor -> ID [ Exp ] .)
    DO              reduce using rule 91 (Factor -> ID [ Exp ] .)
    TO              reduce using rule 91 (Factor -> ID [ Exp ] .)
    DOWNTO          reduce using rule 91 (Factor -> ID [ Exp ] .)


state 181

    (92) Factor -> ID ( ArgumentList ) .

    *               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    /               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    DIV             reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    MOD             reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    +               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    -               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    =               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    NE              reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    <               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    LE              reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    >               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    GE              reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    ,               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    )               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    ;               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    ]               reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    AND             reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    THEN            reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    OR              reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    DO              reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    TO              reduce using rule 92 (Factor -> ID ( ArgumentList ) .)
    DOWNTO          reduce using rule 92 (Factor -> ID ( ArgumentList ) .)


state 182

    (94) ArgumentList -> Exp MoreArguments .

    )               reduce using rule 94 (ArgumentList -> Exp MoreArguments .)


state 183

    (96) MoreArguments -> , . Exp MoreArguments
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 200
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 184

    (56) Block -> WHILE Condition DO BEGIN Blocks . END ;

    END             shift and go to state 201


state 185

    (57) Block -> FOR ID ASSIGN Exp TO . Exp DO Block
    (58) Block -> FOR ID ASSIGN Exp TO . Exp DO BEGIN Blocks END ;
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 202
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 186

    (59) Block -> FOR ID ASSIGN Exp DOWNTO . Exp DO Block
    (60) Block -> FOR ID ASSIGN Exp DOWNTO . Exp DO BEGIN Blocks END ;
    (77) Exp -> . Exp + Term
    (78) Exp -> . Exp - Term
    (79) Exp -> . Term
    (80) Term -> . Term * Factor
    (81) Term -> . Term / Factor
    (82) Term -> . Term DIV Factor
    (83) Term -> . Term MOD Factor
    (84) Term -> . Factor
    (85) Factor -> . INT
    (86) Factor -> . REAL
    (87) Factor -> . STR
    (88) Factor -> . TRUE
    (89) Factor -> . FALSE
    (90) Factor -> . ID
    (91) Factor -> . ID [ Exp ]
    (92) Factor -> . ID ( ArgumentList )
    (93) Factor -> . ( Exp )

    INT             shift and go to state 63
    REAL            shift and go to state 64
    STR             shift and go to state 65
    TRUE            shift and go to state 95
    FALSE           shift and go to state 96
    ID              shift and go to state 66
    (               shift and go to state 90

    Exp                            shift and go to state 203
    Term                           shift and go to state 61
    Factor                         shift and go to state 62

state 187

    (61) Block -> REPEAT Blocks UNTIL Condition ; .

    WRITELN         reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)
    WRITE           reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)
    READLN          reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)
    ID              reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)
    IF              reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)
    WHILE           reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)
    FOR             reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)
    REPEAT          reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)
    END             reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)
    UNTIL           reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)
    ELSE            reduce using rule 61 (Block -> REPEAT Blocks UNTIL Condition ; .)


state 188

    (27) Type -> ARRAY [ INT DOTDOT . INT ] OF Type

    INT             shift and go to state 204


state 189

    (28) Functions -> FUNCTION ID ( Parameters ) : Type . ; FunctionBody

    ;               shift and go to state 205


state 190

    (34) Parameters -> IDList : Type MoreParameters .

    )               reduce using rule 34 (Parameters -> IDList : Type MoreParameters .)


state 191

    (36) MoreParameters -> ; . IDList : Type MoreParameters
    (19) IDList -> . ID RestoIDs

    ID              shift and go to state 23

    IDList                         shift and go to state 206

state 192

    (30) FunctionBody -> Declarations BEGIN . Blocks END ;
    (38) Blocks -> . Block Blocks
    (39) Blocks -> .
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    END             reduce using rule 39 (Blocks -> .)
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Blocks                         shift and go to state 207
    Block                          shift and go to state 29

state 193

    (31) Procedures -> PROCEDURE ID ( Parameters ) ; ProcedureBody .

    VAR             reduce using rule 31 (Procedures -> PROCEDURE ID ( Parameters ) ; ProcedureBody .)
    CONST           reduce using rule 31 (Procedures -> PROCEDURE ID ( Parameters ) ; ProcedureBody .)
    FUNCTION        reduce using rule 31 (Procedures -> PROCEDURE ID ( Parameters ) ; ProcedureBody .)
    PROCEDURE       reduce using rule 31 (Procedures -> PROCEDURE ID ( Parameters ) ; ProcedureBody .)
    BEGIN           reduce using rule 31 (Procedures -> PROCEDURE ID ( Parameters ) ; ProcedureBody .)


state 194

    (33) ProcedureBody -> Declarations BEGIN Blocks END . ;

    ;               shift and go to state 208


state 195

    (43) MoreWriteItems -> , WriteItem MoreWriteItems .

    )               reduce using rule 43 (MoreWriteItems -> , WriteItem MoreWriteItems .)


state 196

    (48) Block -> READLN ( ID [ Exp ] . ) ;

    )               shift and go to state 209


state 197

    (50) Block -> ID [ Exp ] ASSIGN Exp . ;
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    ;               shift and go to state 210
    +               shift and go to state 106
    -               shift and go to state 107


state 198

    (52) Block -> IF Condition THEN Block ELSE Block .

    WRITELN         reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)
    WRITE           reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)
    READLN          reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)
    ID              reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)
    IF              reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)
    WHILE           reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)
    FOR             reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)
    REPEAT          reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)
    END             reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)
    UNTIL           reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)
    ELSE            reduce using rule 52 (Block -> IF Condition THEN Block ELSE Block .)


state 199

    (53) Block -> IF Condition THEN BEGIN Blocks END . ;
    (54) Block -> IF Condition THEN BEGIN Blocks END . ELSE BEGIN Blocks END ;

    ;               shift and go to state 211
    ELSE            shift and go to state 212


state 200

    (96) MoreArguments -> , Exp . MoreArguments
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term
    (96) MoreArguments -> . , Exp MoreArguments
    (97) MoreArguments -> .

    +               shift and go to state 106
    -               shift and go to state 107
    ,               shift and go to state 183
    )               reduce using rule 97 (MoreArguments -> .)

    MoreArguments                  shift and go to state 213

state 201

    (56) Block -> WHILE Condition DO BEGIN Blocks END . ;

    ;               shift and go to state 214


state 202

    (57) Block -> FOR ID ASSIGN Exp TO Exp . DO Block
    (58) Block -> FOR ID ASSIGN Exp TO Exp . DO BEGIN Blocks END ;
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    DO              shift and go to state 215
    +               shift and go to state 106
    -               shift and go to state 107


state 203

    (59) Block -> FOR ID ASSIGN Exp DOWNTO Exp . DO Block
    (60) Block -> FOR ID ASSIGN Exp DOWNTO Exp . DO BEGIN Blocks END ;
    (77) Exp -> Exp . + Term
    (78) Exp -> Exp . - Term

    DO              shift and go to state 216
    +               shift and go to state 106
    -               shift and go to state 107


state 204

    (27) Type -> ARRAY [ INT DOTDOT INT . ] OF Type

    ]               shift and go to state 217


state 205

    (28) Functions -> FUNCTION ID ( Parameters ) : Type ; . FunctionBody
    (30) FunctionBody -> . Declarations BEGIN Blocks END ;
    (3) Declarations -> . Vars Declarations
    (4) Declarations -> . Consts Declarations
    (5) Declarations -> . Functions Declarations
    (6) Declarations -> . Procedures Declarations
    (7) Declarations -> .
    (16) Vars -> . VAR VarList
    (8) Consts -> . CONST ConstDefs
    (28) Functions -> . FUNCTION ID ( Parameters ) : Type ; FunctionBody
    (29) Functions -> . FUNCTION ID : Type ; FunctionBody
    (31) Procedures -> . PROCEDURE ID ( Parameters ) ; ProcedureBody
    (32) Procedures -> . PROCEDURE ID ; ProcedureBody

    BEGIN           reduce using rule 7 (Declarations -> .)
    VAR             shift and go to state 11
    CONST           shift and go to state 12
    FUNCTION        shift and go to state 13
    PROCEDURE       shift and go to state 14

    FunctionBody                   shift and go to state 218
    Declarations                   shift and go to state 169
    Vars                           shift and go to state 7
    Consts                         shift and go to state 8
    Functions                      shift and go to state 9
    Procedures                     shift and go to state 10

state 206

    (36) MoreParameters -> ; IDList . : Type MoreParameters

    :               shift and go to state 219


state 207

    (30) FunctionBody -> Declarations BEGIN Blocks . END ;

    END             shift and go to state 220


state 208

    (33) ProcedureBody -> Declarations BEGIN Blocks END ; .

    VAR             reduce using rule 33 (ProcedureBody -> Declarations BEGIN Blocks END ; .)
    CONST           reduce using rule 33 (ProcedureBody -> Declarations BEGIN Blocks END ; .)
    FUNCTION        reduce using rule 33 (ProcedureBody -> Declarations BEGIN Blocks END ; .)
    PROCEDURE       reduce using rule 33 (ProcedureBody -> Declarations BEGIN Blocks END ; .)
    BEGIN           reduce using rule 33 (ProcedureBody -> Declarations BEGIN Blocks END ; .)


state 209

    (48) Block -> READLN ( ID [ Exp ] ) . ;

    ;               shift and go to state 221


state 210

    (50) Block -> ID [ Exp ] ASSIGN Exp ; .

    WRITELN         reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)
    WRITE           reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)
    READLN          reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)
    ID              reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)
    IF              reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)
    WHILE           reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)
    FOR             reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)
    REPEAT          reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)
    END             reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)
    UNTIL           reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)
    ELSE            reduce using rule 50 (Block -> ID [ Exp ] ASSIGN Exp ; .)


state 211

    (53) Block -> IF Condition THEN BEGIN Blocks END ; .

    WRITELN         reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)
    WRITE           reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)
    READLN          reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)
    ID              reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)
    IF              reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)
    WHILE           reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)
    FOR             reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)
    REPEAT          reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)
    END             reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)
    UNTIL           reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)
    ELSE            reduce using rule 53 (Block -> IF Condition THEN BEGIN Blocks END ; .)


state 212

    (54) Block -> IF Condition THEN BEGIN Blocks END ELSE . BEGIN Blocks END ;

    BEGIN           shift and go to state 222


state 213

    (96) MoreArguments -> , Exp MoreArguments .

    )               reduce using rule 96 (MoreArguments -> , Exp MoreArguments .)


state 214

    (56) Block -> WHILE Condition DO BEGIN Blocks END ; .

    WRITELN         reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)
    WRITE           reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)
    READLN          reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)
    ID              reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)
    IF              reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)
    WHILE           reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)
    FOR             reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)
    REPEAT          reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)
    END             reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)
    UNTIL           reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)
    ELSE            reduce using rule 56 (Block -> WHILE Condition DO BEGIN Blocks END ; .)


state 215

    (57) Block -> FOR ID ASSIGN Exp TO Exp DO . Block
    (58) Block -> FOR ID ASSIGN Exp TO Exp DO . BEGIN Blocks END ;
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    BEGIN           shift and go to state 224
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Block                          shift and go to state 223

state 216

    (59) Block -> FOR ID ASSIGN Exp DOWNTO Exp DO . Block
    (60) Block -> FOR ID ASSIGN Exp DOWNTO Exp DO . BEGIN Blocks END ;
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    BEGIN           shift and go to state 226
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Block                          shift and go to state 225

state 217

    (27) Type -> ARRAY [ INT DOTDOT INT ] . OF Type

    OF              shift and go to state 227


state 218

    (28) Functions -> FUNCTION ID ( Parameters ) : Type ; FunctionBody .

    VAR             reduce using rule 28 (Functions -> FUNCTION ID ( Parameters ) : Type ; FunctionBody .)
    CONST           reduce using rule 28 (Functions -> FUNCTION ID ( Parameters ) : Type ; FunctionBody .)
    FUNCTION        reduce using rule 28 (Functions -> FUNCTION ID ( Parameters ) : Type ; FunctionBody .)
    PROCEDURE       reduce using rule 28 (Functions -> FUNCTION ID ( Parameters ) : Type ; FunctionBody .)
    BEGIN           reduce using rule 28 (Functions -> FUNCTION ID ( Parameters ) : Type ; FunctionBody .)


state 219

    (36) MoreParameters -> ; IDList : . Type MoreParameters
    (22) Type -> . INTEGER
    (23) Type -> . BOOLEAN
    (24) Type -> . STRING
    (25) Type -> . REALTYPE
    (26) Type -> . CHAR
    (27) Type -> . ARRAY [ INT DOTDOT INT ] OF Type

    INTEGER         shift and go to state 71
    BOOLEAN         shift and go to state 72
    STRING          shift and go to state 73
    REALTYPE        shift and go to state 74
    CHAR            shift and go to state 75
    ARRAY           shift and go to state 76

    Type                           shift and go to state 228

state 220

    (30) FunctionBody -> Declarations BEGIN Blocks END . ;

    ;               shift and go to state 229


state 221

    (48) Block -> READLN ( ID [ Exp ] ) ; .

    WRITELN         reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)
    WRITE           reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)
    READLN          reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)
    ID              reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)
    IF              reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)
    WHILE           reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)
    FOR             reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)
    REPEAT          reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)
    END             reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)
    UNTIL           reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)
    ELSE            reduce using rule 48 (Block -> READLN ( ID [ Exp ] ) ; .)


state 222

    (54) Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN . Blocks END ;
    (38) Blocks -> . Block Blocks
    (39) Blocks -> .
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    END             reduce using rule 39 (Blocks -> .)
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Blocks                         shift and go to state 230
    Block                          shift and go to state 29

state 223

    (57) Block -> FOR ID ASSIGN Exp TO Exp DO Block .

    WRITELN         reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)
    WRITE           reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)
    READLN          reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)
    ID              reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)
    IF              reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)
    WHILE           reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)
    FOR             reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)
    REPEAT          reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)
    END             reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)
    UNTIL           reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)
    ELSE            reduce using rule 57 (Block -> FOR ID ASSIGN Exp TO Exp DO Block .)


state 224

    (58) Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN . Blocks END ;
    (38) Blocks -> . Block Blocks
    (39) Blocks -> .
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    END             reduce using rule 39 (Blocks -> .)
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Blocks                         shift and go to state 231
    Block                          shift and go to state 29

state 225

    (59) Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .

    WRITELN         reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)
    WRITE           reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)
    READLN          reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)
    ID              reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)
    IF              reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)
    WHILE           reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)
    FOR             reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)
    REPEAT          reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)
    END             reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)
    UNTIL           reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)
    ELSE            reduce using rule 59 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO Block .)


state 226

    (60) Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN . Blocks END ;
    (38) Blocks -> . Block Blocks
    (39) Blocks -> .
    (40) Block -> . WRITELN ( WriteList ) ;
    (41) Block -> . WRITE ( WriteList ) ;
    (47) Block -> . READLN ( ID ) ;
    (48) Block -> . READLN ( ID [ Exp ] ) ;
    (49) Block -> . ID ASSIGN Exp ;
    (50) Block -> . ID [ Exp ] ASSIGN Exp ;
    (51) Block -> . IF Condition THEN Block
    (52) Block -> . IF Condition THEN Block ELSE Block
    (53) Block -> . IF Condition THEN BEGIN Blocks END ;
    (54) Block -> . IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ;
    (55) Block -> . WHILE Condition DO Block
    (56) Block -> . WHILE Condition DO BEGIN Blocks END ;
    (57) Block -> . FOR ID ASSIGN Exp TO Exp DO Block
    (58) Block -> . FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ;
    (59) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO Block
    (60) Block -> . FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ;
    (61) Block -> . REPEAT Blocks UNTIL Condition ;

    END             reduce using rule 39 (Blocks -> .)
    WRITELN         shift and go to state 30
    WRITE           shift and go to state 31
    READLN          shift and go to state 32
    ID              shift and go to state 33
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    REPEAT          shift and go to state 37

    Blocks                         shift and go to state 232
    Block                          shift and go to state 29

state 227

    (27) Type -> ARRAY [ INT DOTDOT INT ] OF . Type
    (22) Type -> . INTEGER
    (23) Type -> . BOOLEAN
    (24) Type -> . STRING
    (25) Type -> . REALTYPE
    (26) Type -> . CHAR
    (27) Type -> . ARRAY [ INT DOTDOT INT ] OF Type

    INTEGER         shift and go to state 71
    BOOLEAN         shift and go to state 72
    STRING          shift and go to state 73
    REALTYPE        shift and go to state 74
    CHAR            shift and go to state 75
    ARRAY           shift and go to state 76

    Type                           shift and go to state 233

state 228

    (36) MoreParameters -> ; IDList : Type . MoreParameters
    (36) MoreParameters -> . ; IDList : Type MoreParameters
    (37) MoreParameters -> .

    ;               shift and go to state 191
    )               reduce using rule 37 (MoreParameters -> .)

    MoreParameters                 shift and go to state 234

state 229

    (30) FunctionBody -> Declarations BEGIN Blocks END ; .

    VAR             reduce using rule 30 (FunctionBody -> Declarations BEGIN Blocks END ; .)
    CONST           reduce using rule 30 (FunctionBody -> Declarations BEGIN Blocks END ; .)
    FUNCTION        reduce using rule 30 (FunctionBody -> Declarations BEGIN Blocks END ; .)
    PROCEDURE       reduce using rule 30 (FunctionBody -> Declarations BEGIN Blocks END ; .)
    BEGIN           reduce using rule 30 (FunctionBody -> Declarations BEGIN Blocks END ; .)


state 230

    (54) Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks . END ;

    END             shift and go to state 235


state 231

    (58) Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks . END ;

    END             shift and go to state 236


state 232

    (60) Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks . END ;

    END             shift and go to state 237


state 233

    (27) Type -> ARRAY [ INT DOTDOT INT ] OF Type .

    ;               reduce using rule 27 (Type -> ARRAY [ INT DOTDOT INT ] OF Type .)
    )               reduce using rule 27 (Type -> ARRAY [ INT DOTDOT INT ] OF Type .)


state 234

    (36) MoreParameters -> ; IDList : Type MoreParameters .

    )               reduce using rule 36 (MoreParameters -> ; IDList : Type MoreParameters .)


state 235

    (54) Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END . ;

    ;               shift and go to state 238


state 236

    (58) Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END . ;

    ;               shift and go to state 239


state 237

    (60) Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END . ;

    ;               shift and go to state 240


state 238

    (54) Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .

    WRITELN         reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)
    WRITE           reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)
    READLN          reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)
    ID              reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)
    IF              reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)
    WHILE           reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)
    FOR             reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)
    REPEAT          reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)
    END             reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)
    UNTIL           reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)
    ELSE            reduce using rule 54 (Block -> IF Condition THEN BEGIN Blocks END ELSE BEGIN Blocks END ; .)


state 239

    (58) Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .

    WRITELN         reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)
    WRITE           reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)
    READLN          reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)
    ID              reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)
    IF              reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)
    WHILE           reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)
    FOR             reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)
    REPEAT          reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)
    END             reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)
    UNTIL           reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)
    ELSE            reduce using rule 58 (Block -> FOR ID ASSIGN Exp TO Exp DO BEGIN Blocks END ; .)


state 240

    (60) Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .

    WRITELN         reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)
    WRITE           reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)
    READLN          reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)
    ID              reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)
    IF              reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)
    WHILE           reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)
    FOR             reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)
    REPEAT          reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)
    END             reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)
    UNTIL           reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)
    ELSE            reduce using rule 60 (Block -> FOR ID ASSIGN Exp DOWNTO Exp DO BEGIN Blocks END ; .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 143 resolved as shift
WARNING: reduce/reduce conflict in state 59 resolved using rule (CondFactor -> TRUE)
WARNING: rejected rule (Factor -> TRUE) in state 59
WARNING: reduce/reduce conflict in state 60 resolved using rule (CondFactor -> FALSE)
WARNING: rejected rule (Factor -> FALSE) in state 60
WARNING: reduce/reduce conflict in state 93 resolved using rule (WriteItem -> STR)
WARNING: rejected rule (Factor -> STR) in state 93
